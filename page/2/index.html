<!DOCTYPE html><html lang="en"><head><!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]--><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="YSH"><meta property="og:type" content="website"><meta property="og:title" content="Hexo"><meta property="og:url" content="http://nmhn.github.io/page/2/index.html"><meta property="og:site_name" content="Hexo"><meta property="og:locale" content="en_US"><meta property="article:author" content="YSH"><meta name="twitter:card" content="summary"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml"><link rel="shortcut icon" href="/favicon.png"><link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet"><link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet"><script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet"><link rel="stylesheet" href="/css/style.css"><style>.article{opacity:0}</style><link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet"><title>Hexo</title><script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script><script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script><script>var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: 
    }</script><script>yiliaConfig.jquery_ui=[!1]</script><script>yiliaConfig.rootUrl="/"</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="container"><div class="left-col"><div class="overlay"></div><div class="intrude-less"><header id="header" class="inner"><a href="/" class="profilepic"><img src="/img/avatar.png" class="animated zoomIn"></a><hgroup><h1 class="header-author"><a href="/"></a></h1></hgroup><div id="switch-btn" class="switch-btn"><div class="icon"><div class="icon-ctn"><div class="icon-wrap icon-house" data-idx="0"><div class="birdhouse"></div><div class="birdhouse_holes"></div></div><div class="icon-wrap icon-ribbon hide" data-idx="1"><div class="ribbon"></div></div><div class="icon-wrap icon-link hide" data-idx="2"><div class="loopback_l"></div><div class="loopback_r"></div></div><div class="icon-wrap icon-me hide" data-idx="3"><div class="user"></div><div class="shoulder"></div></div></div></div><div class="tips-box hide"><div class="tips-arrow"></div><ul class="tips-inner"><li>Menu</li><li>Tags</li><li>Friends</li><li>About Me</li></ul></div></div><div id="switch-area" class="switch-area"><div class="switch-wrap"><section class="switch-part switch-part1"><nav class="header-menu"><ul><li><a href="/">主页</a></li><li><a href="/archives/">所有文章</a></li><li><a href="/tags/">标签云</a></li><li><a href="/about/">关于我</a></li></ul></nav><nav class="header-nav"><ul class="social"><a class="fa Email" href="mailto:123@123.com" title="Email"></a> <a class="fa GitHub" href="#" title="GitHub"></a> <a class="fa RSS" href="/atom.xml" title="RSS"></a></ul></nav></section><section class="switch-part switch-part2"><div class="widget tagcloud" id="js-tagcloud"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/MC/" rel="tag">MC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/" rel="tag">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VM/" rel="tag">VM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/" rel="tag">android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/class3/" rel="tag">class3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/computer/" rel="tag">computer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/csapp/" rel="tag">csapp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/database/" rel="tag">database</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/exp8/" rel="tag">exp8</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/qemu/" rel="tag">qemu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%80%E5%B7%A7/" rel="tag">技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%A1%E7%AE%97%E6%9C%BA/" rel="tag">操作系统,计算机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A0%81/" rel="tag">编码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80/" rel="tag">网络地址</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%B1%82/" rel="tag">网络层</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" rel="tag">计算机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%BD%91/" rel="tag">计网</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" rel="tag">软件体系结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E8%AF%84%E6%B5%8B%E6%8A%80%E6%9C%AF/" rel="tag">软件质量与评测技术</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul></div></section><section class="switch-part switch-part3"><div id="js-friends"><a class="main-nav-link switch-friends-link" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> <a class="main-nav-link switch-friends-link" target="_blank" rel="noopener" href="https://pages.github.com/">GitHub</a> <a class="main-nav-link switch-friends-link" target="_blank" rel="noopener" href="http://moxfive.xyz/">MOxFIVE</a></div></section><section class="switch-part switch-part4"><div id="js-aboutme">专注于前端</div></section></div></div></header></div></div><div class="mid-col"><nav id="mobile-nav"><div class="overlay"><div class="slider-trigger"></div><h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页"></a></h1></div><div class="intrude-less"><header id="header" class="inner"><a href="/" class="profilepic"><img src="/img/avatar.png" class="animated zoomIn"></a><hgroup><h1 class="header-author"><a href="/" title="回到主页"></a></h1></hgroup><nav class="header-menu"><ul><li><a href="/">主页</a></li><li><a href="/archives/">所有文章</a></li><li><a href="/tags/">标签云</a></li><li><a href="/about/">关于我</a></li><div class="clearfix"></div></ul></nav><nav class="header-nav"><ul class="social"><a class="fa Email" target="_blank" href="mailto:123@123.com" title="Email"></a> <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a> <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a></ul></nav></header></div><link class="menu-list" tags="Tags" friends="Friends" about="About Me"></nav><div class="body-wrap"><article id="post-0929CPU虚拟化" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2022/09/29/0929CPU%E8%99%9A%E6%8B%9F%E5%8C%96/" class="article-date"><time datetime="2022-09-29T00:43:00.000Z" itemprop="datePublished">2022-09-29</time></a></div><div class="article-inner"><input type="hidden" class="isFancy"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/2022/09/29/0929CPU%E8%99%9A%E6%8B%9F%E5%8C%96/">CPU虚拟化</a></h1></header><div class="article-entry" itemprop="articleBody"><h2 id="MAIN-TASK-执行虚拟机程序指令，响应虚拟机内外部事件"><a href="#MAIN-TASK-执行虚拟机程序指令，响应虚拟机内外部事件" class="headerlink" title="MAIN TASK: 执行虚拟机程序指令，响应虚拟机内外部事件"></a>MAIN TASK: 执行虚拟机程序指令，响应虚拟机内外部事件</h2><h2 id="面临的挑战"><a href="#面临的挑战" class="headerlink" title="面临的挑战"></a>面临的挑战</h2><h3 id="1-敏感非特权指令"><a href="#1-敏感非特权指令" class="headerlink" title="1. 敏感非特权指令"></a>1. 敏感非特权指令</h3><p>挑战来源： 基于 陷入-模拟 机制的虚拟化架构只能在所有敏感指令都是特权指令的架构中被建立<br>敏感指令： 操作敏感物理资源的指令，如I&#x2F;O指令、页表基地址切换指令等<br>特权指令； 必须运行在最高特权级的指令，在非特权级中执行这些指令将会触发特权级切换。<br>解决方案：</p><blockquote><p>软件方案： 解释执行【无脑解释执行所有指令，效率较低】，二进制翻译【将敏感指令替换为其他指令，会增加指令数量】，扫描与修补【在执行前，将敏感指令替换为特权指令，代码局部性较差】，半虚拟化【在执行敏感指令的时候通过超调用主动陷入Hypervisor中，避免扫描二进制代码引入的开销，但是打破了虚拟机和Hypervisor之间的界限】<br>硬件辅助方案： Intel VT-x,AMD SVM, ARM EL2, RISC-V H-Extension<br>将所有敏感指令转化为特权指令【可能存在兼容性问题】<br>引入虚拟化模式</p></blockquote><h3 id="2-上下文切换"><a href="#2-上下文切换" class="headerlink" title="2. 上下文切换"></a>2. 上下文切换</h3><p>类似进程上下文，虚拟机发生退出时需要保持各寄存器的状态<br>发生虚拟CPU调度时，需要保存当前虚拟CPU的上下文兵加载待调度虚拟CPU上下文</p><h3 id="3-中断处理"><a href="#3-中断处理" class="headerlink" title="3. 中断处理"></a>3. 中断处理</h3><p>模拟方式：为每一个虚拟机维护一个虚拟中断控制器</p><h1 id="QEMU-x2F-KVM-CPU虚拟化实现"><a href="#QEMU-x2F-KVM-CPU虚拟化实现" class="headerlink" title="QEMU&#x2F;KVM CPU虚拟化实现"></a>QEMU&#x2F;KVM CPU虚拟化实现</h1></div><div class="article-info article-info-index"><div class="article-category tagcloud"><a class="article-category-link" href="/categories/%E5%A4%A7%E5%9B%9B/">大四</a></div><div class="article-tag tagcloud"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" rel="tag">计算机</a></li></ul></div><div class="clearfix"></div></div></div></article><article id="post-22-09-18-csapp02" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2022/09/18/22-09-18-csapp02/" class="article-date"><time datetime="2022-09-18T05:21:00.000Z" itemprop="datePublished">2022-09-18</time></a></div><div class="article-inner"><input type="hidden" class="isFancy"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/2022/09/18/22-09-18-csapp02/">floats</a></h1></header><div class="article-entry" itemprop="articleBody"><h1 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h4 id="浮点通过移动二进制小数点来表示尽可能大的取值范围"><a href="#浮点通过移动二进制小数点来表示尽可能大的取值范围" class="headerlink" title="浮点通过移动二进制小数点来表示尽可能大的取值范围"></a>浮点通过移动二进制小数点来表示尽可能大的取值范围</h4><h3 id="数字公式"><a href="#数字公式" class="headerlink" title="数字公式"></a>数字公式</h3><p>$$<br>(-1)^S M 2^E<br>$$</p><p>符号位{S} 表示正负</p><p>小数{M} 一般是一个1~2之间的小数值</p><p>指数位{E} 指的是乘2的E次方</p><h3 id="IEEE浮点数标准"><a href="#IEEE浮点数标准" class="headerlink" title="IEEE浮点数标准"></a>IEEE浮点数标准</h3><h4 id="single-单精度"><a href="#single-单精度" class="headerlink" title="single 单精度"></a>single 单精度</h4><p>1位符号位，8位指数位，23位小数位</p><h4 id="Double-双精度"><a href="#Double-双精度" class="headerlink" title="Double 双精度"></a>Double 双精度</h4><p>1位符号位，11位指数位，52位小数位</p><h3 id="小数位的特殊表示"><a href="#小数位的特殊表示" class="headerlink" title="小数位的特殊表示"></a>小数位的特殊表示</h3><p>由于小数位永远是1.010101这样的模式</p><p>因此前面的1不放入存储，只记录后面的01010101这种</p><p>同时，在计算时，会刻意维持小数位为1.010111这样的模式，就是说维持小数位在1~2之间</p><h3 id="零表示法"><a href="#零表示法" class="headerlink" title="零表示法"></a>零表示法</h3><p>$$<br>(-1)^S M 2^E<br>$$</p><p>此时E为1-Bias，之前为0-Bias</p><p>由于之前无法表示0，将M设置为0.110101010这种模式，此时可以表示0</p><h4 id="当E全0，小数位全0的时候"><a href="#当E全0，小数位全0的时候" class="headerlink" title="当E全0，小数位全0的时候"></a>当E全0，小数位全0的时候</h4><p>表示0</p><p>这会导致正负0的出现</p><p>当E为0，小数位不为0的时候，可以表示一些很接近0的东西</p><h4 id="如果E为111111…-1-，frac-不为0，"><a href="#如果E为111111…-1-，frac-不为0，" class="headerlink" title="如果E为111111….1 ，frac 不为0，"></a>如果E为111111….1 ，frac 不为0，</h4><p>则代表一个极大值，不代表数字</p></div><div class="article-info article-info-index"><div class="article-tag tagcloud"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/csapp/" rel="tag">csapp</a></li></ul></div><div class="clearfix"></div></div></div></article><article id="post-2022-09-17-csapp01" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2022/09/17/2022-09-17-csapp01/" class="article-date"><time datetime="2022-09-17T10:37:57.000Z" itemprop="datePublished">2022-09-17</time></a></div><div class="article-inner"><input type="hidden" class="isFancy"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/2022/09/17/2022-09-17-csapp01/">Bits Bytes and Integers</a></h1></header><div class="article-entry" itemprop="articleBody"><h1 id="Bits-Bytes-and-Integers"><a href="#Bits-Bytes-and-Integers" class="headerlink" title="Bits,Bytes and Integers"></a>Bits,Bytes and Integers</h1><h2 id="基础位运算"><a href="#基础位运算" class="headerlink" title="基础位运算"></a>基础位运算</h2><h3 id="分清-amp-，-amp-amp-，-，-，-，-之间的区别"><a href="#分清-amp-，-amp-amp-，-，-，-，-之间的区别" class="headerlink" title="分清&amp;，&amp;&amp;，| ，||，~，!之间的区别"></a>分清&amp;，&amp;&amp;，| ，||，~，!之间的区别</h3><p>位操作： &amp;，|，~，运算时只是单纯进行位操作</p><p>逻辑比较： &amp;&amp;，||，！，运算时会添加逻辑考虑，</p><blockquote><p>比如||前面的为True，则提前中止调用</p><p>又比如，对一个非0的数进行！两次会获得一个1，这和位操作有很大的区别</p></blockquote><h3 id="算术右移和逻辑右移"><a href="#算术右移和逻辑右移" class="headerlink" title="算术右移和逻辑右移"></a>算术右移和逻辑右移</h3><p>逻辑右移： 将整个数字向右移动，同时高位补0</p><p>算术右移： 将整个数字向右移动，同时高位按照<strong>符号位补充</strong></p><h4 id="左移的特殊情况"><a href="#左移的特殊情况" class="headerlink" title="左移的特殊情况"></a>左移的特殊情况</h4><p>如果一个八位的数字进行左移八位的操作，在部分计算机中，这个8将被模8，因此并不能得到想象中的0</p><h3 id="补码-T"><a href="#补码-T" class="headerlink" title="补码 T"></a>补码 T</h3><p>国内讲法： 除了符号位，全部按位取反再加1</p><p>这课的讲法：最高位视为负权，如[-16,8,4,2,1]</p><p>经典图片</p><p><img src="/image/2022-09-17-csapp01/1663413629124.png" alt="1663413629124"></p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>例如：8位-&gt;16位</p><p>基本规则：将符号位复制k份，k为扩展位数</p><blockquote><p>解释，想象负数的情况，假设最高位权重暂时是-8，增加一位最高位，新增一位-16，但之前的最高位变为+8，刚好抵消。</p></blockquote><h2 id="加减乘除"><a href="#加减乘除" class="headerlink" title="加减乘除"></a>加减乘除</h2><p>无符号数直接不谈</p><p>补码加法： 可以通过补码加法简单得到减法，只要加上负的值就行</p><h3 id="正-x2F-负溢出"><a href="#正-x2F-负溢出" class="headerlink" title="正&#x2F;负溢出"></a>正&#x2F;负溢出</h3><p>正溢出：俩正数加起来等于一个负数</p><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><p>如果乘2的倍数，只需要【算术】移位就行了，不管是不是补码表示</p><h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><p>同样是算术移位，但这回如果是负数，它就不是四舍五入，而是向负无穷舍入,例如 -3&#x2F;2&#x3D;-2。而不是-1</p><h3 id="获得相反数"><a href="#获得相反数" class="headerlink" title="获得相反数"></a>获得相反数</h3><p>按位取反再+1</p><h3 id="一个恐怖的案例"><a href="#一个恐怖的案例" class="headerlink" title="一个恐怖的案例"></a>一个恐怖的案例</h3><p><img src="/image/2022-09-17-csapp01/1663426748805.png" alt="1663426748805"></p><p>这里，i会被隐式转换成unsigned int(因为sizeof是 unsigned int)，于是这个for循环不会结束</p><h3 id="无符号数的优点"><a href="#无符号数的优点" class="headerlink" title="无符号数的优点"></a>无符号数的优点</h3><p>由于无符号数的计算采用取模的方式</p><p>在一些模运算时（比如大多数加密算法）</p><p>当位表示集合而非数字时，用无符号数最好。</p><h3 id="字存储"><a href="#字存储" class="headerlink" title="字存储"></a>字存储</h3><p>最低有效字节在小端序电脑中放在首位，在大端机器中放在末位</p></div><div class="article-info article-info-index"><div class="article-tag tagcloud"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/computer/" rel="tag">computer</a></li></ul></div><div class="clearfix"></div></div></div></article><article id="post-2022-09-11-计组复习" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2022/09/11/2022-09-11-%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/" class="article-date"><time datetime="2022-09-11T15:12:15.000Z" itemprop="datePublished">2022-09-11</time></a></div><div class="article-inner"><input type="hidden" class="isFancy"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/2022/09/11/2022-09-11-%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/">计组复习</a></h1></header><div class="article-entry" itemprop="articleBody"><h1 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h1><p>基本格式： 操作码| 地址码 （字节的整数倍）</p><h3 id="地址码结构"><a href="#地址码结构" class="headerlink" title="地址码结构"></a>地址码结构</h3><blockquote><p>四地址指令： A1 OP A2 -&gt; A3 4次访存</p><p>三地址： 四地址-A3 （通过PC+1获得下一条指令位置） 4次访存</p><p>二地址： 三地址-A3 （ 结果存放在A1位置）4次访存</p><p>一地址： A_cc OP A1-&gt;Acc (Acc在累加寄存器中) 2次访存</p><p>零地址： 都在堆栈中</p></blockquote><h3 id="操作码"><a href="#操作码" class="headerlink" title="操作码"></a>操作码</h3><p>定长： 简化架构，但利用率低</p><p>变长：设计复杂，但同字节长度下可支持较多指令</p><h3 id="编址方式"><a href="#编址方式" class="headerlink" title="编址方式"></a>编址方式</h3><p>目的： 指出操作数的来源和去向</p><p>需要编址的：通用寄存器，主存，输入输出设备</p><h4 id="编址单位"><a href="#编址单位" class="headerlink" title="编址单位"></a>编址单位</h4><blockquote><ol><li>字编址<br>编址单位&#x3D;访问单位，每个编址单位所包含的信息量与读写寄存器所得的信息量相同</li><li>字节编址<br>编址单位&lt;访问单位<br>编址单位和信息的基本单位（一个字节）相一致</li><li>位编址<br>先不谈</li></ol></blockquote><h4 id="地址码的位数"><a href="#地址码的位数" class="headerlink" title="地址码的位数"></a>地址码的位数</h4><p>与主存容量成正比，和最小寻址单位成反比</p><h3 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h3><p>目的：找到所需的操作数</p><blockquote><ol><li>立即寻址<br>直接取出操作数</li><li>寄存器寻址<br>给出寄存器编号，再访问寄存器取出操作数</li><li>直接寻址<br>取出操作数再主存中的地址</li><li>间接寻址<br>从主存中取出存放操作数地址的地址</li><li>寄存器间接寻址<br>获取寄存器编号，寄存器中该编号存放操作数在主存的地址</li><li>变址寻址<br>读取形式地址A加上变址寄存器Rx的值，获取真实地址</li><li>基址寻址<br>读取位移量D，与基址寄存器中的值相加获得真是地址</li><li>相对寻址<br>相对于基址寻址，由程序寄存器提供基准地址</li><li>页面寻址<br>将整个主存空间分成若干个大小相同的页，每页有自己的编号，称为页面地址，业内的主存单元也有自己的编号，称为页内地址，操作数的有效地址就被分为：页面地址和页内地址两部分<br>有三种页面寻址方式<ol><li>基页寻址<br>有效地址为 0&#x2F;&#x2F;A （&#x2F;&#x2F;为简单拼接)</li><li>当前页寻址<br>页面地址为程序计数器PC的高位部分，有效地址为(PC)h &#x2F;&#x2F; A</li><li>页寄存器寻址<br>页面地址取自页寄存器，与形式地址拼接形成操作数有效地址<br>EA&#x3D;(页寄存器)&#x2F;&#x2F;A</li></ol></li></ol></blockquote><h3 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h3><p>目的：寻找下一条要执行的指令地址</p><h4 id="顺序寻址："><a href="#顺序寻址：" class="headerlink" title="顺序寻址："></a>顺序寻址：</h4><p>PC+1(程序计数器加1)</p><h4 id="跳跃寻址："><a href="#跳跃寻址：" class="headerlink" title="跳跃寻址："></a>跳跃寻址：</h4><p>通过程序转移类指令实现</p><p>直接、相对、间接寻址（详见数据寻址）</p><h2 id="堆栈与堆栈操作"><a href="#堆栈与堆栈操作" class="headerlink" title="堆栈与堆栈操作"></a>堆栈与堆栈操作</h2><h3 id="堆栈结构"><a href="#堆栈结构" class="headerlink" title="堆栈结构"></a>堆栈结构</h3><blockquote><ol><li>寄存器堆栈<br>一组专门的寄存器构成，栈顶固定，且组中寄存器互相连接，可将一个寄存器中的内容推移到另一个寄存器中去</li><li>存储器堆栈<br>从主存中划出一块区域来当堆栈，大小可变，栈底固定，栈顶浮动，需要一个硬件寄存器作为堆栈栈顶指针SP<br>PS: 栈底指针地址大于栈顶地址，因此进栈时，栈顶指针先减一，然后将数据压入指针指向的堆栈位置</li></ol></blockquote><h3 id="堆栈操作（用途）"><a href="#堆栈操作（用途）" class="headerlink" title="堆栈操作（用途）"></a>堆栈操作（用途）</h3><p>【一般计算机】</p><ol><li>暂存中断断点</li><li>子程序调用时的返回地址</li><li>状态标志</li><li>现场信息</li><li>子程序调用时参数的传递</li></ol><p>因此访问堆栈的指令只有进栈和出栈两种。</p><h2 id="指令类型"><a href="#指令类型" class="headerlink" title="指令类型"></a>指令类型</h2><h3 id="数据传送类指令"><a href="#数据传送类指令" class="headerlink" title="数据传送类指令"></a>数据传送类指令</h3><p>用于寄存器与寄存器，寄存器与主存 ，主存与主存之间的数据传送</p><ol><li>一般传送指令：将源地址的数据复制到目的地址</li><li>堆栈操作指令：因为堆栈（主存中开辟的）是一个特殊区域，因此对堆栈的操作也就是对存储器的操作</li><li>数据交换指令：将源操作数和目的地操作数相互交换位置</li></ol><h3 id="运算类指令"><a href="#运算类指令" class="headerlink" title="运算类指令"></a>运算类指令</h3><ol><li>算术运算指令</li><li>逻辑运算指令</li><li>移位指令（算数移位【保持操作数符号不变，左移数值*2，右移数值&#x2F;2】，逻辑移位【不管符号】，循环移位）</li></ol><h3 id="程序控制类指令"><a href="#程序控制类指令" class="headerlink" title="程序控制类指令"></a>程序控制类指令</h3><p>用于控制程序的执行方向，并使程序具有测试、分析与判断的能力</p><ol><li>转移指令<br>无条件（JMP）： 直接吧程序转向新的位置执行<br>条件转移：条件满足才转移</li><li>子程序调用指令<br>子程序是一组可以公用的指令序列，只要知道地址就能调用<br>主程序转向子程序称为子程序调用指令（CALL）<br>子程序转向主程序成为转移指令（RET）<br>一般使用堆栈保持返回地址</li><li>返回指令（RET）</li></ol><h3 id="输入输出类指令"><a href="#输入输出类指令" class="headerlink" title="输入输出类指令"></a>输入输出类指令</h3><p>实现主机与外部设备之间的信息交换</p><h4 id="独立编址的IO"><a href="#独立编址的IO" class="headerlink" title="独立编址的IO"></a>独立编址的IO</h4><p>独立编址：外设端口和主存单元独立编址，指令系统有专门的IN&#x2F;OUT指令，信息从外设到主机称为输入</p><p>指令中给出外设端口地址，这些地址是另一个独立的地址空间</p><h4 id="统一编址的IO"><a href="#统一编址的IO" class="headerlink" title="统一编址的IO"></a>统一编址的IO</h4><p>指令系统没有专门的IO指令，用一般的数据传送类指令来实现</p><h2 id="数值的机器运算"><a href="#数值的机器运算" class="headerlink" title="数值的机器运算"></a>数值的机器运算</h2><h2 id="基本算数运算的实现"><a href="#基本算数运算的实现" class="headerlink" title="基本算数运算的实现"></a>基本算数运算的实现</h2><p>并行可以加快过程，但并行会使计算式过长，因此采用并串联合使用的方式取得性能和逻辑的平衡</p><ol><li>单级先行进位方式<br>组内并行，组间串行</li><li>多级先行进位方式<br>组内并行，组间也并行</li></ol><h2 id="定点加减运算"><a href="#定点加减运算" class="headerlink" title="定点加减运算"></a>定点加减运算</h2><p>补码加法：[X+Y]补&#x3D;[X]补+[Y]补</p><p>减法也只是加补码求反后的结果</p><p>后面的先不看了</p><h2 id="存储系统和结构"><a href="#存储系统和结构" class="headerlink" title="存储系统和结构"></a>存储系统和结构</h2><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><h3 id="按作用分类"><a href="#按作用分类" class="headerlink" title="按作用分类"></a>按作用分类</h3><ol><li>高速缓冲存储器</li></ol><p>位于主存和CPU之间</p><ol start="2"><li>主存储器</li></ol><p>CPU 可直接访问</p><ol start="3"><li>辅助存储器</li></ol><p>CPU不能直接访问</p><h3 id="存取方式分类"><a href="#存取方式分类" class="headerlink" title="存取方式分类"></a>存取方式分类</h3><ol><li>RAM 随机存取<br>存取时间相同，随机读写访问</li><li>ROM 只读<br>特殊的RAM，只能读不能写</li><li>SAM 顺序存取<br>只能按某种顺序存取，存取时间与存储体上的物理位置有关</li><li>DAM 直接存取存储器<br>读取步骤： 第一步直接指向存储器中的某个小区域，第二部在小区域内顺序检索</li></ol><h3 id="存取层次结构"><a href="#存取层次结构" class="headerlink" title="存取层次结构"></a>存取层次结构</h3><p>cache 主存 辅存 分为两个层次</p><h4 id="Cache-主存-存储层次"><a href="#Cache-主存-存储层次" class="headerlink" title="Cache-主存 存储层次"></a>Cache-主存 存储层次</h4><p>目的：解决主存速度不足</p><p>方式： 在CPU和主存之间，增加辅助硬件，让他们构成一个整体，使CPU速度接近cache，容量接近主存</p><h4 id="主存-辅存存储层次"><a href="#主存-辅存存储层次" class="headerlink" title="主存 - 辅存存储层次"></a>主存 - 辅存存储层次</h4><p>目的：解决主存容量不足</p><h2 id="主存储器的组织"><a href="#主存储器的组织" class="headerlink" title="主存储器的组织"></a>主存储器的组织</h2><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>存储体</p><p>地址译码驱动电路</p><ul><li>译码器和驱动器，译码器将地址总线输入的地址吗转换成输出线上的有效电平，驱动器提供驱动电流去驱动相应的读写电路</li></ul><p>IO和读写电路</p><h3 id="存储单元"><a href="#存储单元" class="headerlink" title="存储单元"></a>存储单元</h3><p>位： 二进制数的最基本单位，也是存储器存储信息的最小单位</p><p>存储字：一个二进制数由若干位组成，当这个二进制数作为一个整体存入或取出时，这个数称为存储字</p><p>存储单元（主存单元) 存放存储字或存储字节的主存空间，由计算机的结构确定。是CPU对主存可访问擦欧总的最小存储单位。</p><p>存储体： 大量存储单元集合构成一个存储体</p><h3 id="技术指标"><a href="#技术指标" class="headerlink" title="技术指标"></a>技术指标</h3><ol><li>存储容量<br>指主存所能容纳的二进制信息总量，对字节编址的计算机，以字节数表示，对字编址的计算机，以字数和字长的乘积来表示</li><li>存取速度<br>2.1 存取时间<br>从启动一次存储器操作到完成该操作所经历的时间<br>2.2 存取周期<br>指存储器进行一次完整的读写操作所需的全部时间，连续两次访问存储器操作之间所需要的最短时间</li><li>主存带宽<br>每秒从主存进出信息的最大数量（字&#x2F;秒或 字节&#x2F; 秒 或 位&#x2F; 秒）</li></ol><h2 id="半导体随机存储器和只读存储器"><a href="#半导体随机存储器和只读存储器" class="headerlink" title="半导体随机存储器和只读存储器"></a>半导体随机存储器和只读存储器</h2><h3 id="动态RAM的刷新"><a href="#动态RAM的刷新" class="headerlink" title="动态RAM的刷新"></a>动态RAM的刷新</h3><h4 id="刷新方式"><a href="#刷新方式" class="headerlink" title="刷新方式"></a>刷新方式</h4><h5 id="集中式"><a href="#集中式" class="headerlink" title="集中式"></a>集中式</h5><p>集中安排若干个刷新周期，刷新时停止读写操作</p><p>时间&#x3D;存储体矩阵行数*刷新周期</p><h5 id="分散式"><a href="#分散式" class="headerlink" title="分散式"></a>分散式</h5><p>把刷新操作分散到每个存取周期内进行，此时存取周期被分成读写和刷新两个部分。</p><h5 id="异步式"><a href="#异步式" class="headerlink" title="异步式"></a>异步式</h5><p>把刷新操作平均分配到整个最大刷新间隔时间内进行</p><p>刷新间隔&#x3D;最大刷新间隔时间&#x2F; 行数</p><h3 id="主存容量的扩展"><a href="#主存容量的扩展" class="headerlink" title="主存容量的扩展"></a>主存容量的扩展</h3></div><div class="article-info article-info-index"><div class="article-tag tagcloud"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/computer/" rel="tag">computer</a></li></ul></div><div class="clearfix"></div></div></div></article><article id="post-2022-09-04-微型数据库开发记录" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2022/09/04/2022-09-04-%E5%BE%AE%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/" class="article-date"><time datetime="2022-09-04T15:35:57.000Z" itemprop="datePublished">2022-09-04</time></a></div><div class="article-inner"><input type="hidden" class="isFancy"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/2022/09/04/2022-09-04-%E5%BE%AE%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/">微型数据库开发记录</a></h1></header><div class="article-entry" itemprop="articleBody"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>近三周应小学期老师要求，和4位队友合作开发了一个微型数据库系统。由于耗费了许多的精力，我想将开发过程记录在这个博客上。</p><h2 id="功能性需求："><a href="#功能性需求：" class="headerlink" title="功能性需求："></a>功能性需求：</h2><ol><li>创建数据库和表，能够以文件形式保存在磁盘上（操作系统的文 件、进程管理，数据结构 的 B树）</li><li>支持表的增删改查（数据库 中SQL形式，编译的词法语法检查）</li><li>SQL中支持通配符（数据结构的查找）、多表连接（操作系统 的 文件管理）</li><li>支持整数、实数、字符（串）、日期等数据类型</li><li>支持索引（数据库、数据结构 ）</li></ol><h2 id="性能性需求"><a href="#性能性需求" class="headerlink" title="性能性需求"></a>性能性需求</h2><ol><li>单表记录最大行数不少于10万行，不少于10 列</li><li>单表响应时间不多于 1秒（普通笔记本）</li><li>主表不少于5000行，子表不少于20000行时，连接操作响应时 间不多于 2 秒</li></ol><h1 id="痛苦的开端"><a href="#痛苦的开端" class="headerlink" title="痛苦的开端"></a>痛苦的开端</h1><h2 id="最初的迷茫"><a href="#最初的迷茫" class="headerlink" title="最初的迷茫"></a>最初的迷茫</h2><p>开始的时候确实是啥也不知道，一堆人在教室里商量了半天也没想明白该干些什么，就留了两天各自查资料。等大家查完，在教室里一讨论，就发现任务极其重大。由于要实现5000*20000级别的表连接，还有100 000级别的数据插入，因此我们需要考虑底层的文件存储，但由于开发经验的不足和工期较短，我们在讨论中断定，凭空实现完全的页面管理对我们来说是不可能的，因此决定退而求其次，找一份有页面管理的借鉴一下。</p><p>因此，我们翻看了sqlite的源码，还通篇学习了一门斯坦福的课程（代码仓库叫redbase）,在途中，还重新确定了我们要实现的关键字等需求。</p><h2 id="借鉴都借鉴不明白"><a href="#借鉴都借鉴不明白" class="headerlink" title="借鉴都借鉴不明白"></a>借鉴都借鉴不明白</h2><p>然后就出现了问题，我们找到了一份很好的页面管理代码，但光页面管理（包括缓冲区管理）的代码量就直接超过了8000行，为了实现它我们需要做的工作过于繁复（虽然我们确实尝试了一天）。</p><p>同时，Linux开发也对我们组造成了较大的麻烦，因为有开发经验的仅有一人，其他人光环境配置就花了很长时间。后来采用先富带后富的方式，总算是搞定了整组的环境。</p><h2 id="借鉴不了，想一个自己的框架吧！"><a href="#借鉴不了，想一个自己的框架吧！" class="headerlink" title="借鉴不了，想一个自己的框架吧！"></a>借鉴不了，想一个自己的框架吧！</h2><p>最后，我们发现，我们的这种特种需求，只有我们自己琢磨一个框架来才能够满足3周内开发完成，且能够实现一定的文件管理和查询优化。</p><p>这里用文字形容一下我们初步商量的框架</p><blockquote><p>顶层：词法分析-&gt;语法分析，产出一棵抽象语法树</p><p>中层：语义分析，并实现一系列数据库操作函数</p><p>底层：B+树代码和物理存储管理代码，存储二进制数据。</p></blockquote><p>中层咱暂时实在想不明白，就先大致写了一点儿，之后先把顶层和底层开发出来，到时候再看中层该怎么搞。</p><h1 id="辛苦又充满成长的开发过程"><a href="#辛苦又充满成长的开发过程" class="headerlink" title="辛苦又充满成长的开发过程"></a>辛苦又充满成长的开发过程</h1><p>经历了鸡飞狗跳，还有一堆学校其他杂事（搬家，做华为云实验）的一周之后，我们正式开始开发。</p><h2 id="顶层"><a href="#顶层" class="headerlink" title="顶层"></a>顶层</h2><p>顶层被我们归类为最困难的工作，我们想了些取巧的办法让它稍微简单一点儿。这块儿是组里大佬写的，我也只是有所了解。</p><p>参考redbase的顶层（就算是斯坦福的课，顶层代码也是预先写好，不用学生写的），我们按照自己的需求写了一份语法文件，并用yacc（应该）生成分析代码。</p><h2 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h2><p>第二周折腾了老半天，把一份B+树代码折腾出来了，它还满足我们的要求（改泛型改了一个周末）：能够存储int，float和string类型的数据（本来还有个要求是，一级索引将和纯数据文件放在一起，方便存取，但泛型这东西实在不是一个初学c++的同志能整的这么明白的，就没实现）</p><h3 id="数据文件（初版）"><a href="#数据文件（初版）" class="headerlink" title="数据文件（初版）"></a>数据文件（初版）</h3><p>这里给出示例文件框架</p><blockquote><p>save</p><p>-table1 示例表名</p><p>–table1.data存放二进制数据文件</p><p>—-table1.meta存放表说明文件</p><p>—-IND&#x2F;&#x2F;存放索引</p><p>——-table1&#x2F;&#x2F;自增主键索引</p><p>—其他索引</p></blockquote></div><div class="article-info article-info-index"><div class="article-tag tagcloud"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/database/" rel="tag">database</a></li></ul></div><div class="clearfix"></div></div></div></article><article id="post-2022-04-02-字节二面记录" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2022/04/02/2022-04-02-%E5%AD%97%E8%8A%82%E4%BA%8C%E9%9D%A2%E8%AE%B0%E5%BD%95/" class="article-date"><time datetime="2022-04-02T12:01:01.000Z" itemprop="datePublished">2022-04-02</time></a></div><div class="article-inner"><input type="hidden" class="isFancy"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/2022/04/02/2022-04-02-%E5%AD%97%E8%8A%82%E4%BA%8C%E9%9D%A2%E8%AE%B0%E5%BD%95/">字节二面记录</a></h1></header><div class="article-entry" itemprop="articleBody"><h1 id="2022-x2F-4-x2F-2-字节二面记录"><a href="#2022-x2F-4-x2F-2-字节二面记录" class="headerlink" title="2022&#x2F;4&#x2F;2 字节二面记录"></a>2022&#x2F;4&#x2F;2 字节二面记录</h1><blockquote><p>啸问题:开头以为只有暑假可以实习,直接被面试官拒了,然后被同学提醒才发现开学也能实习,紧急联系回来了</p><p>面试官还挺好的,居然还能继续面</p></blockquote><h2 id="问了些啥"><a href="#问了些啥" class="headerlink" title="问了些啥"></a>问了些啥</h2><p>最开始还是最难顶的自我介绍,感觉像是一个垃圾桶被要求介绍自己(x),我下次应该记住重复一下北理是个985,不然听起来像个野鸡大学(</p><p>和一面不同的是,这回自我介绍完了就开始做题,还问了python里头元组和字典的关系(答不出来,寄)</p><p>计网方面问了http请求一个页面的过程(上学期刚上完这学期就忘得差不多了属于是)</p><p>这回没问数据库,不知道是为啥</p><p>问了对软件项目管理的理解(?),我就当问我管理上的看法,感觉有点答非所问</p><h2 id="哪里不行"><a href="#哪里不行" class="headerlink" title="哪里不行"></a>哪里不行</h2><p>对语言的理解比较烂,属于是只知道用不知道学</p><p>计网还是得看看http请求的全过程</p><p>其实数据库查询语句还有点欠缺,不过能用</p></div><div class="article-info article-info-index"><div class="article-tag tagcloud"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul></div><div class="clearfix"></div></div></div></article><article id="post-2022-03-14-React学习20220314 虚拟DOM" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2022/03/16/2022-03-14-React%E5%AD%A6%E4%B9%A020220314%20%E8%99%9A%E6%8B%9FDOM/" class="article-date"><time datetime="2022-03-16T03:48:15.000Z" itemprop="datePublished">2022-03-16</time></a></div><div class="article-inner"><input type="hidden" class="isFancy"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/2022/03/16/2022-03-14-React%E5%AD%A6%E4%B9%A020220314%20%E8%99%9A%E6%8B%9FDOM/">React学习20220314 虚拟DOM</a></h1></header><div class="article-entry" itemprop="articleBody"><h1 id="React学习20220314-虚拟DOM"><a href="#React学习20220314-虚拟DOM" class="headerlink" title="React学习20220314 虚拟DOM"></a>React学习20220314 虚拟DOM</h1><h2 id="虚拟DOM是什么"><a href="#虚拟DOM是什么" class="headerlink" title="虚拟DOM是什么"></a>虚拟DOM是什么</h2><p>是JS和DOM之间的一个映射缓存，在形态上表现为一个能够描述DOM结构及其属性信息的JS对象。</p><p>在REACT中，表现为</p><p><img src="G:/WorkStation/JavaScriptProject/React%E5%AD%A6%E4%B9%A0/React%E5%AD%A6%E4%B9%A020220314%20%E8%99%9A%E6%8B%9FDOM/assets/image-20220314142105501.png" alt="image-20220314142105501"></p><p>是JS对象，是对真实DOM的描述</p><h2 id="如何工作"><a href="#如何工作" class="headerlink" title="如何工作"></a>如何工作</h2><blockquote><ul><li>挂载阶段：结合JSX的描述，构建出虚拟DOM树，然后通过ReactDOM.render实现虚拟DOM到真实DOM的映射</li><li>更新阶段，页面的变化在作用于真实DOM之前，先作用于虚拟DOM，虚拟DOM在JS层借助算法先对比出那些真实DOM需要被改变，然后将改变作用于真实DOM</li></ul></blockquote><p>这一段历史讲得好有趣，摘下来</p><p><img src="G:/WorkStation/JavaScriptProject/React%E5%AD%A6%E4%B9%A0/React%E5%AD%A6%E4%B9%A020220314%20%E8%99%9A%E6%8B%9FDOM/assets/image-20220314142856250.png" alt="image-20220314142856250"></p><p><img src="G:/WorkStation/JavaScriptProject/React%E5%AD%A6%E4%B9%A0/React%E5%AD%A6%E4%B9%A020220314%20%E8%99%9A%E6%8B%9FDOM/assets/image-20220314145559439.png" alt="image-20220314145559439"></p><p><img src="G:/WorkStation/JavaScriptProject/React%E5%AD%A6%E4%B9%A0/React%E5%AD%A6%E4%B9%A020220314%20%E8%99%9A%E6%8B%9FDOM/assets/image-20220314145616729.png" alt="image-20220314145616729"></p><p data-nodeid="6717">可以看出，模板语法其实就是把 JS 和 HTML 结合在一起的一种规则，而模板引擎做的事情也非常容易理解。</p><p data-nodeid="6718">把 staff 这个数据源读进去，塞到预置好的 HTML 模板里，然后把两者融合在一起，吐出一段目标字符串给你。这段字符串的内容，其实就是一份标准的、可用于渲染的 HTML 代码，它将对应一个 DOM 元素。最后，将这个 DOM 元素挂载到页面中去，整个模板的渲染流程也就走完了。</p><p data-nodeid="6719">这个过程可以用伪代码来表示，如下所示：</p><pre class="lang-js" data-nodeid="6720"><code data-language="js"><span class="hljs-comment">// 数据和模板融合出 HTML 代码</span>
<span class="hljs-keyword">var</span> targetDOM = template(&#123;<span class="hljs-attr">data</span>: students&#125;)
<span class="hljs-comment">// 添加到页面中去</span>
<span class="hljs-built_in">document</span>.body.appendChild(targetDOM)
</code></pre><p data-nodeid="6721">当然，实际的过程会比我们描述的要复杂一些。这里我补充一下模板引擎的实现思路，供感兴趣的同学参考。模板引擎一般需要做下面几件事情：</p><ol data-nodeid="6722"><li data-nodeid="6723"><p data-nodeid="6724">读取 HTML 模板并解析它，分离出其中的 JS 信息；</p></li><li data-nodeid="6725"><p data-nodeid="6726">将解析出的内容拼接成字符串，动态生成 JS 代码；</p></li><li data-nodeid="6727"><p data-nodeid="6728">运行动态生成的 JS 代码，吐出“目标 HTML”；</p></li><li data-nodeid="6729"><p data-nodeid="6730">将“目标 HTML”赋值给 innerHTML，触发渲染流水线，完成真实 DOM 的渲染。</p></li></ol><p data-nodeid="6731">使用模板引擎方案来渲染数据是非常爽的：每次数据发生变化时，我们都不用关心到底是哪里的数据变了，也不用手动去点对点完成 DOM 的修改。只<strong data-nodeid="6882">需要关注的仅仅是数据和数据变化本身</strong>，DOM 层面的改变模板引擎会帮我们做掉。</p><p data-nodeid="6732">如此看来，模板引擎像极了一个只需要接收命令，就能够把活干得漂漂亮亮的“扫地机器人”！可惜的是，模板引擎出现的契机虽然是为了使用户界面与业务数据相分离，但实际的应用场景基本局限在“实现高效的字符串拼接”这一个点上，因此不能指望它去做太复杂的事情。尤其令人无法接受的是，<strong data-nodeid="6888">它在性能上的表现并不尽如人意</strong>：由于不够“智能”，它更新 DOM 的方式是将已经渲染出 DOM 整体注销后再整体重渲染，并且不存在更新缓冲这一说。在 DOM 操作频繁的场景下，模板引擎可能会直接导致页面卡死。</p><blockquote data-nodeid="6733"><p data-nodeid="6734">注：请注意小标题中“早期”这个限定词——本课时所讨论的“模板引擎”概念，指的是虚拟 DOM 思想推而广之以前，相对原始的一类模板引擎，这类模板引擎曾经主导了一个时代。但时下来看，越来越多的模板引擎正在引入虚拟 DOM，模板引擎最终也将走向现代化。</p></blockquote><p data-nodeid="6735">虽然指望模板引擎实现生产力解放有些天方夜谭，但模板引擎在思想上无疑具备高度的先进性：允许程序员只关心数据而不必关心 DOM 细节的这一操作，和 React 的“数据驱动视图”思想如出一辙，实在是高！</p><h3 data-nodeid="6736">那该怎么办呢？</h3><p data-nodeid="6737">jQuery 救不了加班写 DOM 操作的前端，模板引擎也救不了，那该怎么办呢？</p><p data-nodeid="6738">这时候有一批仁人志士，兴许是从模板引擎的设计思想上得到了启发，他们明确了要走“数据驱动视图”这条基本道路，于是便沿着这个思路往下摸索：模板引擎的数据驱动视图方案，核心问题在于对真实 DOM 的修改过于“大刀阔斧”，导致了 DOM 操作的范围过大、频率过高，进而可能会导致糟糕的性能。然后这帮人就想啊：既然操作真实 DOM 对性能损耗这么大，那我操作假的 DOM 不就行了？</p><p data-nodeid="6739">沿着这个思路再往下走，就有了我们都爱的虚拟 DOM。</p><blockquote data-nodeid="6740"><p data-nodeid="6741">注：出于严谨，还是要解释下。真实历史中的虚拟 DOM 创作过程，到底有没有向模板引擎去学习，这个暂时无从考证。但是按照前端发展的过程来看，模板引擎和虚拟 DOM 确实在思想上存在递进关系，很多场景下，面试官也可能会问及两者的关系。因此在此处，我采取了这样一种表述方式，希望能够帮助你更好地把握住问题的关键所在。</p></blockquote><p>虚拟DOM使得之前的全局刷新，改成了有更新的部分更新，在真实DOM前加了一层</p><p><img src="G:/WorkStation/JavaScriptProject/React%E5%AD%A6%E4%B9%A0/React%E5%AD%A6%E4%B9%A020220314%20%E8%99%9A%E6%8B%9FDOM/assets/image-20220314151706530.png" alt="image-20220314151706530"></p><p>虚拟DOM解决的问题重心不是性能</p><p><img src="G:/WorkStation/JavaScriptProject/React%E5%AD%A6%E4%B9%A0/React%E5%AD%A6%E4%B9%A020220314%20%E8%99%9A%E6%8B%9FDOM/assets/image-20220314151854443.png" alt="image-20220314151854443"></p><h1 id="Reconciliation过程与Diff算法"><a href="#Reconciliation过程与Diff算法" class="headerlink" title="Reconciliation过程与Diff算法"></a>Reconciliation过程与Diff算法</h1><h2 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h2><p>找两个树结构之间的不同</p><h3 id="两个规律"><a href="#两个规律" class="headerlink" title="两个规律"></a>两个规律</h3><p><img src="G:/WorkStation/JavaScriptProject/React%E5%AD%A6%E4%B9%A0/React%E5%AD%A6%E4%B9%A020220314%20%E8%99%9A%E6%8B%9FDOM/assets/image-20220314152249841.png" alt="image-20220314152249841"></p><p><img src="G:/WorkStation/JavaScriptProject/React%E5%AD%A6%E4%B9%A0/React%E5%AD%A6%E4%B9%A020220314%20%E8%99%9A%E6%8B%9FDOM/assets/image-20220314153544145.png" alt="image-20220314153544145"></p><p>对于Key，下图可以比较好地展示使用了Key后的更新策略</p><p><img src="G:/WorkStation/JavaScriptProject/React%E5%AD%A6%E4%B9%A0/React%E5%AD%A6%E4%B9%A020220314%20%E8%99%9A%E6%8B%9FDOM/assets/image-20220314153745501.png" alt="image-20220314153745501"></p><p>如果不使用key，则仅有AB可保留，其他均被重建</p></div><div class="article-info article-info-index"><div class="article-tag tagcloud"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/" rel="tag">React</a></li></ul></div><div class="clearfix"></div></div></div></article><article id="post-2022-03-14-React学习20220314 SetState" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2022/03/16/2022-03-14-React%E5%AD%A6%E4%B9%A020220314%20SetState/" class="article-date"><time datetime="2022-03-16T03:48:15.000Z" itemprop="datePublished">2022-03-16</time></a></div><div class="article-inner"><input type="hidden" class="isFancy"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/2022/03/16/2022-03-14-React%E5%AD%A6%E4%B9%A020220314%20SetState/">React学习20220314 SetState</a></h1></header><div class="article-entry" itemprop="articleBody"><h1 id="React学习20220314-SetState"><a href="#React学习20220314-SetState" class="headerlink" title="React学习20220314 SetState"></a>React学习20220314 SetState</h1><h2 id="初始认知"><a href="#初始认知" class="headerlink" title="初始认知"></a>初始认知</h2><p>setState之后立马访问对应state，会发现它并没有改变，而是会在之后某个时间发生变化</p><h2 id="异步的动机和原理"><a href="#异步的动机和原理" class="headerlink" title="异步的动机和原理"></a>异步的动机和原理</h2><img src="https://s0.lgstatic.com/i/image/M00/6D/8A/Ciqc1F-uMeSAYK6FAABN0Vwnq5M814.png" alt="图片3.png" data-nodeid="13893"><h2 id="异步避免重复reRender"><a href="#异步避免重复reRender" class="headerlink" title="异步避免重复reRender"></a>异步避免重复reRender</h2><p><img src="G:/WorkStation/JavaScriptProject/React%E5%AD%A6%E4%B9%A0/typoimg/image-20220314185248371.png" alt="image-20220314185248371"></p><h2 id="从源码角度看异步setState"><a href="#从源码角度看异步setState" class="headerlink" title="从源码角度看异步setState"></a>从源码角度看异步setState</h2><p><img src="G:/WorkStation/JavaScriptProject/React%E5%AD%A6%E4%B9%A0/typoimg/image-20220314185446537.png" alt="image-20220314185446537"></p><h2 id="再查看batchingStrategy"><a href="#再查看batchingStrategy" class="headerlink" title="再查看batchingStrategy"></a>再查看batchingStrategy</h2><p><img src="G:/WorkStation/JavaScriptProject/React%E5%AD%A6%E4%B9%A0/typoimg/image-20220314185810854.png" alt="image-20220314185810854"></p><h2 id="理解Transaction（事务）机制"><a href="#理解Transaction（事务）机制" class="headerlink" title="理解Transaction（事务）机制"></a>理解Transaction（事务）机制</h2><p><img src="G:/WorkStation/JavaScriptProject/React%E5%AD%A6%E4%B9%A0/typoimg/image-20220314185913490.png" alt="image-20220314185913490"></p><h2 id="同步现象的本质"><a href="#同步现象的本质" class="headerlink" title="同步现象的本质"></a>同步现象的本质</h2><p><img src="G:/WorkStation/JavaScriptProject/React%E5%AD%A6%E4%B9%A0/typoimg/image-20220314190033221.png" alt="image-20220314190033221"></p></div><div class="article-info article-info-index"><div class="article-tag tagcloud"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/" rel="tag">React</a></li></ul></div><div class="clearfix"></div></div></div></article><article id="post-2022-03-13-React学习20220313 Hook" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2022/03/13/2022-03-13-React%E5%AD%A6%E4%B9%A020220313%20Hook/" class="article-date"><time datetime="2022-03-13T03:48:15.000Z" itemprop="datePublished">2022-03-13</time></a></div><div class="article-inner"><input type="hidden" class="isFancy"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/2022/03/13/2022-03-13-React%E5%AD%A6%E4%B9%A020220313%20Hook/">React学习20220313 Hook</a></h1></header><div class="article-entry" itemprop="articleBody"><h1 id="React学习20220313-Hook"><a href="#React学习20220313-Hook" class="headerlink" title="React学习20220313 Hook"></a>React学习20220313 Hook</h1><h2 id="理解Hook"><a href="#理解Hook" class="headerlink" title="理解Hook"></a>理解Hook</h2><p>按我的理解，Hook是对繁琐，学习曲线长，难以更改中间步骤的类的拆分，使得函数可以拥有一些类能够使用的功能：如state和生命周期等，而且Hook所辅助的函数式编程比较符合React所推崇的组件化编程。</p><h2 id="对useState的理解"><a href="#对useState的理解" class="headerlink" title="对useState的理解"></a>对useState的理解</h2><p>充当函数中的state，但一次只有一个，不像类中一次指定多个</p><blockquote><p>[text,setText] &#x3D;useState(‘初始文字’)</p></blockquote><p>useState返回一个数组，数组第一个是想要的state变量，第二个是修改变量的Api</p><h2 id="对useEffect的理解"><a href="#对useEffect的理解" class="headerlink" title="对useEffect的理解"></a>对useEffect的理解</h2><p>弥补生命周期</p><p>接收两个参数：回调函数和依赖数组</p><p>useEffect(callBack,[])</p><p>调用规则：</p><blockquote><p>每次渲染后：传入回调函数，不传依赖数组：</p><ul><li>useEffect(callBack)</li></ul><p>挂载阶段执行一次后不再执行：传入回调函数，且此函数的返回值不是函数，同时传入空数组。</p><ul><li>useEffect(()&#x3D;&gt;{&#x2F;*业务逻辑*&#x2F;},[])</li></ul><p>仅在挂载和卸载阶段执行的：传入回调函数，且此函数的返回值是一个函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="comment">//业务逻辑</span></span><br><span class="line"><span class="comment">//返回一个函数记为B</span></span><br><span class="line"><span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,[])</span><br></pre></td></tr></table></figure><p>每次渲染都触发，且卸载阶段也会被触发的：传入回调函数，且这个函数的返回值是一个函数，同时不传第二个参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//A的业务逻辑</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回一个函数记为B</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面这段代码在每次渲染都触发A逻辑，并在卸载阶段触发B逻辑</p><p>按我的理解，在前面一半写个函数会在渲染阶段一直触发，单纯写一段逻辑就会在挂载阶段触发，在return那写个函数就会在卸载的时候触发</p></blockquote><p><img src="G:/WorkStation/JavaScriptProject/React%E5%AD%A6%E4%B9%A0/React%E5%AD%A6%E4%B9%A020220313%20Hook/assets/image-20220313160121838.png" alt="image-20220313160121838"></p><h2 id="不要在循环，条件或嵌套函数中调用Hook"><a href="#不要在循环，条件或嵌套函数中调用Hook" class="headerlink" title="不要在循环，条件或嵌套函数中调用Hook"></a>不要在循环，条件或嵌套函数中调用Hook</h2><h3 id="首次渲染过程"><a href="#首次渲染过程" class="headerlink" title="首次渲染过程"></a>首次渲染过程</h3><p><img src="G:/WorkStation/JavaScriptProject/React%E5%AD%A6%E4%B9%A0/React%E5%AD%A6%E4%B9%A020220313%20Hook/assets/image-20220314135945234.png" alt="image-20220314135945234"></p><p>hook相关的所有信息收敛在一个hook对象粒，而hook对象之间以单向链表的形式相互串联，</p><h3 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h3><p><img src="G:/WorkStation/JavaScriptProject/React%E5%AD%A6%E4%B9%A0/React%E5%AD%A6%E4%B9%A020220313%20Hook/assets/image-20220314140737526.png" alt="image-20220314140737526"></p><p>因此，hooks的渲染是通过“依次遍历”（也就是说，它只会管这回需要前进几个next，而不会对对应位置的真实性进行判断）来定位每个hooks的内容的，如果前后两次读到的链表顺序出现差异，那么渲染的结果自然是不可控的。</p></div><div class="article-info article-info-index"><div class="article-tag tagcloud"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/" rel="tag">React</a></li></ul></div><div class="clearfix"></div></div></div></article><article id="post-2022-03-12-React学习20220312" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2022/03/12/2022-03-12-React%E5%AD%A6%E4%B9%A020220312/" class="article-date"><time datetime="2022-03-12T03:48:15.000Z" itemprop="datePublished">2022-03-12</time></a></div><div class="article-inner"><input type="hidden" class="isFancy"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/2022/03/12/2022-03-12-React%E5%AD%A6%E4%B9%A020220312/">React学习20220312 生命周期</a></h1></header><div class="article-entry" itemprop="articleBody"><h1 id="React学习20220312"><a href="#React学习20220312" class="headerlink" title="React学习20220312"></a>React学习20220312</h1><h2 id="CreateElement函数拆解"><a href="#CreateElement函数拆解" class="headerlink" title="CreateElement函数拆解"></a>CreateElement函数拆解</h2><img src="C:\Users\www13\AppData\Roaming\Typora\typora-user-images\image-20220312150556893.png" alt="image-20220312150556893" style="zoom:50%"> <img src="C:\Users\www13\AppData\Roaming\Typora\typora-user-images\image-20220312150653145.png" alt="image-20220312150653145" style="zoom:50%"> <img src="C:\Users\www13\AppData\Roaming\Typora\typora-user-images\image-20220312150814067.png" alt="image-20220312150814067" style="zoom:50%"> <img src="C:\Users\www13\AppData\Roaming\Typora\typora-user-images\image-20220312150922420.png" alt="image-20220312150922420" style="zoom:50%"><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><img src="C:\Users\www13\AppData\Roaming\Typora\typora-user-images\image-20220312151139289.png" alt="image-20220312151139289"></p><p>React16</p><p><img src="C:\Users\www13\AppData\Roaming\Typora\typora-user-images\image-20220312152345970.png" alt="image-20220312152345970"></p><blockquote><p>挂载过程</p><img src="C:\Users\www13\AppData\Roaming\Typora\typora-user-images\image-20220312152839851.png" alt="image-20220312152839851" style="zoom:50%"><p>getDerivedFromProps的功能：使用props来派生&#x2F;更新state</p><ul><li>是针对某个属性的定向更新</li></ul><p>更新过程</p><img src="C:\Users\www13\AppData\Roaming\Typora\typora-user-images\image-20220312153339553.png" alt="image-20220312153339553" style="zoom:50%"><p>getSnapshotBeforeUpdate:</p><img src="C:\Users\www13\AppData\Roaming\Typora\typora-user-images\image-20220312154540844.png" alt="image-20220312154540844" style="zoom:50%"> <img src="C:\Users\www13\AppData\Roaming\Typora\typora-user-images\image-20220312154512940.png" alt="image-20220312154512940" style="zoom:50%"></blockquote><p>React16引入的Fiber架构</p><p>之前组件更新：树状递归更新，同步更新，占用主线程，易卡死</p><p>Fiber会把大任务转为小任务，使得渲染线程可打断</p><p>重要特征</p><blockquote><p>可以被<u>打断</u>的异步渲染模式</p></blockquote><p>react将渲染过程分为render和commit两个过程</p><p>render可被打断</p><p>commit同步执行</p><p>因为commit会改视图，因此不可打断</p><h2 id="数据的流动"><a href="#数据的流动" class="headerlink" title="数据的流动"></a>数据的流动</h2><p>基于props的单向数据流：</p><blockquote><p>当前组件的state以props的形式流动时，只能流向组件树中比自己层级更低的组件</p></blockquote><p>父子组件通信</p><blockquote><p>父组件把this.props传入子组件</p></blockquote><p>子父组件通信</p><blockquote><p>父组件向子组件传递一个绑定了自身上下文的函数</p><p>子组件在调用该函数时，</p><p>就可以把想要交给父组件的数据以函数入参的形式传入</p><blockquote><img src="C:\Users\www13\AppData\Roaming\Typora\typora-user-images\image-20220312163654393.png" alt="image-20220312163654393" style="zoom:50%"> <img src="C:\Users\www13\AppData\Roaming\Typora\typora-user-images\image-20220312163734257.png" alt="image-20220312163734257" style="zoom:50%"> <img src="C:\Users\www13\AppData\Roaming\Typora\typora-user-images\image-20220312163752751.png" alt="image-20220312163752751" style="zoom:50%"></blockquote></blockquote></div><div class="article-info article-info-index"><div class="article-tag tagcloud"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/" rel="tag">React</a></li></ul></div><div class="clearfix"></div></div></div></article><nav id="page-nav"><a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &amp;raquo;</a></nav></div><footer id="footer"><div class="outer"><div id="footer-info"><div class="footer-left"><i class="fa fa-copyright"></i> 2016-2023 YSH</div><div class="footer-right"><a href="http://hexo.io/" target="_blank" title="A fast, simple &amp; powerful blog framework">Hexo</a> Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="Another simple and elegant theme for Hexo  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i></div></div><div class="visit"><span id="busuanzi_container_site_pv" style="display:none"><span id="site-visit" title="Site Visitors"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span> </span></span><span>| </span><span id="busuanzi_container_page_pv" style="display:none"><span id="page-visit" title="Page Hits"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span></span></span></div></div></footer></div><script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script><script>$(document).ready(function(){var a,c;-1<window.navigator.userAgent.indexOf("iPad")||"none"===$(".left-col").css("display")?(c=["#9db3f4","#414141","#e5a859","#f5dfc6","#c084a0","#847e72","#cd8390","#996731"],a=Math.ceil(Math.random()*(c.length-1)),$("body").css({"background-color":c[a],"background-size":"cover"})):(c="url(/background/bg-x.jpg)".replace(/x/gi,Math.ceil(5*Math.random())),$("body").css({background:c,"background-attachment":"fixed","background-size":"cover"}))})</script><div class="scroll" id="scroll"><a href="#" title="Back to Top"><i class="fa fa-arrow-up"></i></a> <a href="#comments" onclick="load$hide()" title="Comments"><i class="fa fa-comments-o"></i></a> <a href="#footer" title="Go to Bottom"><i class="fa fa-arrow-down"></i></a></div><script>var x,oOpenInNew={archives:".archive-article-title",miniArchives:"a.post-list-link",friends:"#js-friends a",socail:".social a"};for(x in oOpenInNew)$(oOpenInNew[x]).attr("target","_blank")</script><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>