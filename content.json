{"posts":[{"title":"数据库完整性概述","text":"9.1 数据库完整性概述 数据库完整性–数据的正确性,有效性,西安共性 列级约束 对属性的数据类型,等的定义 元祖约束 元组中各个属性之间的约束关系 实现完整性约束的方法 提供定义机制 提供检查方法 违约处理 9.4用户定义的完整性9.5触发器一类用户定义在关系数据表上的一类由事件驱动的特殊过程,用编程的方法实现复杂的业务规则 是一种特殊类型的存储过程 可用触发器完成很多数据库完整性保护的过程 复杂的业务规则 比较数据修改前后状态 SQL:CREATE TRIGER命令 事务原子性:不可分割 一致性:事务执行结果必须从一个状态转换到另一个状态时保持一致,即若中间出现错误,则将所有操作撤销 事务应当具有ACID性质，A是原子性(atomic)：事务中包含的各项操作必须全部成功执行或者全部不执行。任何一项操作失败，将导致整个事务失败，其他已经执行的任务所作的数据操作都将被撤销，只有所有的操作全部成功，整个事务才算是成功完成。C是一致性(consistent)：保证了当事务结束后，系统状态是一致的。那么什么是一致的系统状态？例如，如果银行始终遵循着”银行账号必须保持正态平衡”的原则，那么银行系统的状态就是一致的。上面的转账例子中，在取钱的过程中，账户会出现负态平衡，在事务结束之后，系统又回到一致的状态。这样，系统的状态对于客户来说，始终是一致的。I是隔离性(isolated)：使得并发执行的事务，彼此无法看到对方的中间状态。保证了并发执行的事务顺序执行，而不会导致系统状态不一致。D是持久性(durable)：保证了事务完成后所作的改动都会被持久化，即使是发生灾难性的失败。可恢复性资源保存了一份事务日志，如果资源发生故障，可以通过日志来将数据重建起来。 事务应处在下列状态之一 活动状态 失败状态:意味着要回滚 中止状态:数据库已经回滚完毕,恢复到提交前状态 提交状态:当数据更改完全写入磁盘时,进入提交状态 10.3.1事务故障的恢复 1.反向扫描日文件日志,查找该事务的更新操作 2.对该事务的更新操作执行你操作 3.继续反向扫描,直到读到此事务的开始操作 10.3.2系统故障恢复 1.正向扫描日志文件,列出Redo队列,Undo队列 日志&lt;u&gt;登记两条原则 &lt;/u&gt; &lt;u&gt;1.登记次序严格按并行事物执行顺序 &lt;/u&gt; &lt;u&gt;2.先写日志文件,后写数据库 &lt;/u&gt;","link":"/2021/12/06/2021-12-06-database-Complication/"},{"title":"21&#x2F;12&#x2F;6 Database 数据库的安全性","text":"数据库的安全性8.4 存取控制用户权限定义和合法的权限检查机制一起组成了DBMS的安全子系统常用存取控制方法 自主存取控制灵活 同一用户对不同的数据对象有不同的… 授权粒度授权的数据对象粒度 数据库,表,属性列,行… 实现–GRANT REVOKE 数据库角色在用户量较大的情况下引入定义:一组与数据库操作有关的角色可以为具有相同权限的用户创建一个角色 权限传播… 强制存取控制主体与客体敏感度标记DBMS为每个实例指派一个敏感度标记 敏感度分为若干级别(绝密.. 主体的敏感度标记称为许可证级别 客体的称为密级 MAC机制就是通过对比主体的Label和客体的Label,最终确定主体是否能够存取客体 强制存取控制规则 读 主体许可证级别&gt;=客体密级 写 主体的许可证级别=客体密级 修正规则***** waiting for write 权限,只有具有合法的许可证才能存取每一个用户被授予某一个级别的许可证 对于任意一个对象,只有具有合法的许可证才能存取 8.5 视图机制","link":"/2021/12/06/2021-12-06-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7/"},{"title":"21&#x2F;12&#x2F;6 Database 查询优化","text":"查询优化游标目的-解决集合性操作语言与过程性操作语言的不匹配原因:sql一条语句一般能产生或处理多条记录,而主语言一次只能存放一条记录是什么:是系统为用户开设的一个数据缓冲区,存放sql语句的执行结果用户可以用SQL语句逐一地从游标中获取记录,并赋给主变量 定义游标: 使用Declare语句EXEC SQL DECLARE &lt;&gt; CURSOR…… 打开游标–执行相应的select语句,吧所有满足查询条件的记录从指定表取到缓冲区中EXEC SQL OPEN &lt;游标名&gt; 此时游标指针指向查询结果集中第一条记录之前 推动游标使用FETCH语句 EXEC SQL FETCH [[NEXT]]…. 指定方向推动游标指针,然后将缓冲区中的当前记录取出来送至主变量供主语言进一步处理 要求:主变量与select语句中的目标列表达式具有一一对应关系 关闭游标CLOSE语句 EXEC SQL CLOSE &lt;游标名&gt; 7.1查询处理过程7.1.1 查询分析对查询语句进行扫描,词法分析和语法分析 7.1.2查询检查根据数据字典中的用户权限和完整性约束定义对用户的存取权限进行检查 检查通过后将SQL查询语句转换成等价的&lt;u&gt;关系代数表达式&lt;/u&gt; 7.1.4查询优化选择一个高效执行的查询处理策略 代数优化-关系代数表达式优化物理优化-存取物理介质及…的优化7.1.5查询执行不用多言 7.2执行查询操作的基本算法1. 选择操作顺序扫描/二分查找/索引[散列]/复合选择 索引–提供元组指针,间接检索 B+树索引:同样是提供元组指针,同时支持顺序集中依次查找 如是 sdept=’cs’ and sae&gt;20:则 算法一:分别查询,求交集 算法而:先找到第一个查询的指针,然后在第一个查询的指针基础上进行第二个查询 2.连接操作连接操作是查询处理中最耗时的操作之一[例2] SELECT * FROM Student,SC WHERE Student.Sno=SC.Sno [例2end] 嵌套循环法对外层循环的每一个元组,检测内层循环中的每一个元组,检查两个元组在连接属性上是否相等满足,即串接后作为结果输出 索引链接法在输出表上建立属性Sno的索引(如果原来没有)对student中每个元组,有Sno值通过Sc…….. 排序合并法适合连接的诸表已经排好序的情况没排序则排序取Student表中第一个sno,然后依次找sc表中具有相同sno的元组扫到sno不相同的第一个sc元组时,返回Student扫描它的下一个元组之后循环 散列连接法把连接属性作为散列码,然后划分 3.投影操作选取关系的某些列,从垂直的方向减小关系的大小如果投影属性列包括了关系R的主键,则操作可言直接执行,操作结果将于R中元组个数相同 否则则需要消除重复元组 4.集合运算操作并,查,交,笛卡尔积 并查缴类似排序合并法 笛卡尔积一般嵌套循环合并 7.3关系数据库系统的查询优化分布式数据库:总代接=I/O代价+***** 7.3.2查询优化实例假定学生-课程数据库中有1000个学生记录,10000个选课记录 其中选修二号课程的选课记录为50个 查询选修了2号课程的学生姓名 第一种情况1.计算广义笛卡尔积-把student和sc的每个元组连接起来的做法 2.做选择操作依次读入连接后的元组,按照选择条件选取满足要求的记录 3.做投影操作把第二步操作的结果在Sname上作投影输出,得到最终输出 第二种情况1.计算自然连接2.读取中间文件块,进行选择操作3.投影输出第三种情况1.先对sc表进行选择运算2.读取Student表,把读入的student元组和内存中收到sc元组做连接3.把连接结果投影输出假如SC表的Cno字段/Student表上的Sno有索引,可加快读取 有选择和连接操作时,先做选择操作–代数优化选择操作算法有权标扫描和索引扫描两种,在第三种情况下,索引扫描效果好–物理优化7.3.3 代数优化关系代数表达式的等价变换规则指用相同的关系代替两个表达式中相应的关系所得到的结果是相同的 常用的等价变换规则代数优化策略-通过对关系代数表达式的等价变化来提高查询效率启发式规则 选择运算尽可能先做,最重要最基本的一条 把投影运算和选择运算同时进行 把投影同其前后的双目运算结合起来 把某些选择同在它前面要执行的笛卡尔积结合起来形成一个连接运算’ 找出公共子表达式 代数优化算法输入:一个查询树 输出:优化的查询树 物理优化代数优化改变查询语句中操作的次序和组合,不涉及底层的存取路径 定义:选择高效合理的操作算法/存取路径 基于存取路径的优化选择操作的启发式规则– 对于小关系,使用全表顺序扫描,即使有索引 对于大关系– 对于选择条件是主键=值的查询选择主键索引 对于选择条件是非主属性=值的查询,且选择列上有索引估算查询结果的元组书目–比例小(10%),索引,比例大-全表 选择条件是属性上的非等值查询或范围查询,且存在索引估算查询结果的元组书目–比例小(10%),索引,比例大-全表 对于用and连接的合取选择条件优先采用组合索引扫描…. or连接一般全表 连接操作的启发式规则 两个比哦啊都已经按照连接属性排序排序合并法 一个表在连接属性上有索引索引连接法 都不是1,2,而其中一个表比较小散列连接法 可以选用嵌套循环阀,并选择较小的表作为外表 基于代价估算的优化二者结合的优化","link":"/2021/12/06/2021-12-06-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"},{"title":"21&#x2F;12&#x2F;7 存储管理-操作系统","text":"存储管理地址访问保护机制 上下界寄存器和地址检查机制 ​ 作业拥有上下界,执行访存指令时,判断是否越界 ​ 要求:作业程序是绝对地址或静态可浮动 2. 基址寄存器、长度寄存器和动态地址转换机制​ 当作业被调度运行时，将作业所占内存基址及长度送基址、长度寄存器，在用户态每次执行访存指令时，先看访问地址是否小于长度，然后+基址进行访存。用户程序代码是动态浮动的 可变分区思想:预先不划分内存，当作业需要时向系统申请，系统从其中挖出一块给该作业Q:空闲区域如何管理? 多道连续可变分区法特点:多道,连续,不固定划分内存管理方法系统设置一个空闲块队列，初始状态时队列中只有一个连续的空闲块。作业到达后，以某种策略分配空间。作业撤离时，将释放的空间加入空闲队列。 释放方法相邻合并,否则插入 例一进入执行顺序:(1,2,3)-&gt;(4)-&gt;(5) 分配方法 首次满足法 从头到尾找,找到的第一个满足它的空间就给它 最佳满足法 从队列中找一个最接近的空闲队列给它 最大满足法 每次找最大的空间给最新创建的进程 可用空间管理紧致机制–将已有的进程挪到一起,腾出大块的连续空间可再定位式分区–浮动分区分配页式存储管理解决作业不连续存放的问题特点： 作业 (进程) 分成页面，内存也划分成页面，将作业 **(进程 **) 页面不连续地分布到内存页面 基本原理 分页逻辑地址 = P(页号).d( 页内位移 ** ) ** 分页物理地址 = f(页帧号).d(同上) P = 线性逻辑地址 / 页面大小； d = 线性逻辑地址 **- P***页面大小。 为什么是2的k次幂?将乘除法转成移位运算 为了取出一个数据，系统需要访问内存几次？–两次:1.取页表,2.取数据 快表由一组联想寄存器(TLB, Translation Lookaside Buffer)组成。 联想寄存器：一种按内容进行并行查找的快速寄存器，访问速度比主存快得多 使用bitmap数组/空闲页帧链管理可用页帧共享通过页表可以使几个逻辑空间指向同一个物理空间，实现程序共享。 越界保护设置页表长度寄存器,查页表前,检查页号是否越界 访问保护在每个页表项中增设一存储保护域，用于说明对该页的访问权限，每一个对该页存储的访问都首先要比照是否满足该页访问权限的说明，满足则访问，否则报异常。 Ø优点ü没有外碎片，每个内碎片不超过页大小。 ü程序不必连续存放。 Ø主要缺点：ü程序要一次全部装入内存才能执行。 ü采用动态地址变换机构会增加计算机的成本和降低处理机的速度。 ü各种数据结构(页表，空闲页表)要占用一定的内存空间，而且系统要花费一定的时间来建立和管理这些表格。 ü依然存在内碎片。 段式存储管理特点:按作业的自然段将其逻辑空间分成若干段，作业以段为单位分配内存。Ø用户作业逻辑空间为二维空间，由若干自然段组成。 Ø 逻辑地址：段号段内偏移，记作S,d。编译及装配时把所有地址记成(S,d)的形式。 Ø 物理内存空间管理：与多道可变划分法一样，系统以段为单位分配物理内存。 段页式管理特点：将作业分成若干段，每段用页式管理实现内存分配 为了获得一条指令或者数据，需要访问内存几次？–3次,段表,页表,数据 内存扩充技术借助大容量的辅存实现内存的扩充覆盖技术将用户空间划分成一个固定区和多个覆盖区。主程序放固定区，依次调用的子程序则放在同一个覆盖区。****操作系统提供覆盖系统调用函数，由用户编程序显式调用 相当于时间换空间 交换技术将处于等待状态(等I/O结束)或就绪(等CPU)状态的作业从主存换出到辅存，把将要执行的进程移入主存。 优点: 提高并发性 缺点: 换入换出增加处理机开销 程序换入时存在重定位问题 和覆盖技术对比 虚拟存储技术基础程序中不是每一条指令都会在程序的一次运行过程中执行到。 错误处理子程序 条件语句(if…else…)程序中有的指令可能只执行一次 程序的初始化部分程序执行的局部性原理：在一段时间内，作业一般不会执行到所有程序的指令，也不会存取绝大部分数据，执行的代码和要存取的数据往往集中在某些区域中(例如一个循环、一个数组)。 目的：提供用户进程一个巨大的虚拟存储空间手段：利用外存(磁盘)实现此虚空间。基本思想系统为进程提供一个比物理内存大得多的虚拟存储空间，虚拟空间大小不受物理内存大小的限制。 虚拟空间的容量由系统的有效地址长度决定。假设地址长度为32，按字节寻址，则虚拟存储空间大小为$2^{32}$个字节。 原理在程序装入时，不必一次将其全部读入到内存，而只需将当前需要执行的某些区域读入到内存，然后程序开始执行。在程序执行过程中，如果需执行的指令或访问的数据尚未在内存，则由处理器通知操作系统将相应的区域调入内存，然后继续执行。 分类虚拟页式页表增加外存标识位和外存地址项当内存中没有空闲页面时，如果还要调入一个新页，如何处理？ ​ 淘汰掉一个内存中的页(淘汰策略) 交换区用来回写数据初始值和初值为0的工作区 页表项结构 合法位：置上表示该页在内存。修改位：置上表示该页被修改过，在释放或淘汰时应写 回外存。页类型：零页时：表示该页在分配物理页帧时应清0页帧 空间;回写swap区页时:表示回写swap区。保护码：R、W、E保护说明。外存块号：该页所在外存的块号。页 帧 号：当合法位置上时代表该页所在内存的页帧号。 缺页处理根据发生页故障的虚地址得到页表项；申请一个可用的页帧(根据所采用的替换策略可能需要引起淘汰某一页);检查页类型，若为零页，则将页帧清0，将页帧号填入页表项的页帧号一栏，置合法位为1。若非零页，则调用I/O子系统将外存块号所指的数据读到可用页帧，将页帧号填入页表项中，合法位置1，结束。 页淘汰查P页表项的修改位，若未修改，则清0合法位，将页帧送回空闲页帧队列。若已修改，则检查类型栏。若是零页或回写swap区页（代表还没有分配交换区空间），则申请一块swap区空间，将P的外存块号置上并清除页类型。调用I/0子系统将页帧上的数据写到外存块号所指的外存空间。清0合法位，将页帧送回空闲页帧队列。 页面置换策略出发点： 把未来不再使用的或者短时期内较少使用的页面调出基本概念 驻留集：进程的合法页集合访问串：进程访问虚拟空间的地址踪迹 举例：某进程依次访问如下地址，0100，0432，0101，0612，0102，0103，… 页式虚存管理以页为基本单位，只需页号即可。设页面大小为100，上述访问串可简化为1，4，1，6，1，1，… 驻留集大小固定的局部置换策略FIFO（先进先出）替换最早进入的页 效果奇差 有Belady奇异 指置换策略不满足随着驻留集的增大，页故障数一定减少的规律。 OPT（最佳算法）需要预先知道整个访问串的序列（因此不可实现） 理论最优 LRU（最近最少使用）淘汰上次使用距当前最远的页 栈算法 LRU策略中，当驻留集大小为m时，S（m，t）中保持着最近使用过的m个页帧；当驻留集大小为m+1时，S（m+1，t）中保持着最近使用过的m+1个页帧。故S（m，t）属于 S（m+1，t），LRU策略是栈算法。 CLOCK基于LRU的思想硬件在页面被访问时设置页表项中的访问位随着表针的移动，淘汰访问位是0的页面，或清除页面的访问位。实用的页面置换算法 NRU(最近未使用)为页帧在页表项中增加一位使用位，硬件每访存一次即将对应页的使用位置1，操作系统页面管理程序定时将所有使用位清0。淘汰时任选一个使用位为0(表示OS清0周期内没被使用过）的页。 操作系统选择淘汰页时，尽量避免选被修改过的页。因此，选择淘汰页次序： 驻留集大小可变的全局置换策略WS若驻留集中某页有$\\triangle$个访问间隔没被访问则将其淘汰(正是因为这个特性,才是动态的) 实现:每一页面设一计数器,每访存一次,将所有其他页计数器+1,所访存的计数器清零,淘汰计数器等于$\\triangle$的页面 实际上:开销太大,没有用SWS定时检查计时器,淘汰计时器值大于等于$\\triangle$的页面(当前时钟值-页表时钟值)&gt;$\\triangle$的页面) 硬件消耗还是很大置换策略选择动态驻留集sws+淘汰页数据延迟清除 设立两个队列：自由链表和修改链表。 定时做页淘汰（SWS）：淘汰时不立即抹去页中数据，根据页面修改否挂入自由链/修改链，修改链过长或自由链过短时，回写页面后改挂到自由链中。 若paging in要用空页时,选自由链的第一页帧，这时页中数据被覆盖。 若在自由链/修改链中的页面再次被访问时，则将该页从链中摘除,使该页又能通过页表项访问到。 123 某计算机采用二级页表的分页存储管理方式，按字节编址，页大小为2^10 字节，页表项大小为2字节，逻辑地址结构为：逻辑地址空间大小为2^16页，则表示整个逻辑地址空间的页目录表中包含表项的个数至少是： ? 逻辑空间: 2^16 *2^10 =2^26 页大小为2^10 页表项大小为2,则一页能写2^9 个页表项 共2^16逻辑页,故需要 2^7页","link":"/2021/12/07/2021-12-07-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/"},{"title":"21&#x2F;12&#x2F;6 Database 数据库操作","text":"数据库select from where group by having order by insert指定属性列–不包含的取空 不指定-不能省略任何属性","link":"/2021/12/06/2021-12-06-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/"},{"title":"21&#x2F;12&#x2F;7 设备管理","text":"设备管理1. 控制器控制器的任务是在外设与内存之间完成比特流与字节块之间的转换1.1寄存器每个控制器有几个寄存器,操作系统可以往里写东西 1.2数据缓冲区有些控制器上有,用于大数据传输 1.2.1磁盘控制器将位流组装为字节存入缓冲区中,形成字节为单位的块 2.控制方式2.1 程序直接控制cpu控制全过程 效率低下(CPU一直在等) 2.2中断控制cpu发送指令,去干别的,等io设备准备好,利用中断通知cpu 2.3 DMA方式(适合高速大量的外设)cpu启动指令-&gt;DMA控制器-&gt;(data)-&gt;启动外设 整个数据的传输都是在DMA控制下进行的 2.4通道控制方式cpu连接多个通道,通道连接多个控制器,再连接外部设备 imgtest 3.设备I/o子系统申请设备 将数据写入设备 从设备读取数据 释放设备 分时式共享使用设备以一次IO为单位分时使用设备 SPOOLING方式使用外设利用磁盘上的输入输出并模拟高速外设 IO的组成I.O交通管制程序 调度程序 设备处理程序 基本思想:分层构建,较低层为较高层服务,使较高层独立于硬件,为用户提供统一接口I/O设计目标 设备独立性–使软硬件相对独立,给上层软件更好的可移植性 设备统一命名-每种设备都是有名称的,如何命名以方便系统管理和用户使用是一个重要的问题 采取预先设计的,统一的逻辑名称 出错处理:数据尽可能在接近硬件层处理,仅当低层无能为力时,才将错误上交 缓冲技术:设法使数据的到达率和离去率匹配,提高系统的吞吐量 设备的分配:共享设备和独占设备的分配问题","link":"/2021/12/07/2021-12-07-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/"},{"title":"21&#x2F;12&#x2F;6 软件体系结构复习-设计模式","text":"策略模式基本原则:责任分离+高内聚低耦合各部分组成及说明 strategy:定义了一个共同的接口,所有的具体算法类实现这个接口.换进该类context调用这个接口调用具体的算法类 ConcreteStragety 封装了具体的算法,实现统一个几口 Context 环境类.用于配置一个具体的算法策略对象,维持一个策略接口类型的参考,并且可以定义一个让接口Strategy的具体对象访问的接口(可省略) 使用策略模式的情况 当有多个行为上不同但是相关的类存在. 当某个算法使用用户不该知道的数据时,使用策略模式可以将算法实现细节隐藏起来. 当一个类有多种行为,这些行为以大块的条件语句实现时,可以将这些条件块移入他们自己的Strategy类中 使用策略模式的出发点 将一组相关的算法封装为各个策略分支,从而将策略分支相关的代码隐藏起来 提升程序的可拓展性 优点 得到一系列可服用的算法,这些算法继承一个共同的抽象类,因此公有的功能可以放到超类中 将不同算法封装在不同的策略子类中,使逻辑更加清晰,各个算法可以独立地变化 是功能改变或拓展变得更容易 创建型模式工厂模式简单工厂 各组成部分的功能 Creater 核心,包含应用程序锁需要的业务逻辑.同时负责委托工厂生产对象 Product 接口/抽象类 是具体子类的超类/接口 ConcreteProduct 实现Product接口/继承Product抽象类 优点 工厂方法包含从一个类的结构中选择初始类的业务逻辑 客户类不直接创建产品类的对象,值作为对象的消费者 实现了责任分离 如果有新产品子类加入,不必修改客户类(前提是客户类不用新产品) 因为1,所以客户类不需要繁杂的逻辑判断 缺点 增加产品类时,要修改工厂类 因为工厂类的工厂方法是静态的,所以工厂类中的方法不能被继承,因此只能承载一个单独的类群,而不是一个有多层结构的类 为了解决简单工厂的缺点—工厂方法工厂方法核心思想:将简单工厂中单一的工厂类改写成一个层次类 类图解释Creater: 接口,含有一个factory方法,然后可以用和产品类相同的结构产生创建者类结构,其中包含CreaterA和CreaterB CreaterA/B:负责创建对应的ProductA和ProductB的对象 和简单工厂的相同之处 方法模式一样,工厂方法也返回一个属于父类Product类型的对象,客户不必知道返回对象的具体类型 和简单工厂的区别 中心不同.工厂方法的中心是抽象工厂类/接口,而简单工厂方法的中心是一个实的工厂类在简单工厂的工厂方法是静态的,而工厂方法是动态的 简单工厂方法不支持开闭原则.而工厂方法支持.简单工厂增加产品类:在工厂类中也应增加条件语句工厂方法增加产品类:在Product类的结构体重增加一个实体,在工厂类层次结构体中增加一个相应的能产生该新产品对象的实类 工厂方法工厂类不必包含创建对象的逻辑判断 使用工厂方法的情况 创建某些类的对象的逻辑比较复杂,并且有很多条件分支 一个类不能准确预知它要创建一个层次类中哪个子类的对象 一个类使用子类决定要创建的对象 需要封装创建类的对象的逻辑,使这些逻辑局部化 抽象工厂模式类图 抽象工厂模式中包含 一系列互相有关联的产品类,(有相同的结构) 一系列实的工厂类,实现由抽象工厂提供的接口.他们各自生产一组相关的产品类对象 当客户对象要从一个相关的产品组中创建一个对象,而没有必要知道到底创建哪个对象时使用抽象工厂抽象工厂方法不符合开闭原则–增加一个新产品层次类,则必须在每个工厂实类中增加方法装饰者模式提供一个比继承更加灵活的方案 类图 访问者模式解决问题–对一个已经完成设计与diamante编写的类的层次结构进行功能修改或增加新功能 类图解释 VIsitor: 为每个element的类声明了一个访问操作 concreteVisitor: 实现Visitor声明的运算 Element: 定义了一些基本的方法,包含提供基本数据的方法.重要的是,它的子类必须定义一个接收者方法,为被访问者对象和访问者对象之间提供接口 ConcreteElement :具体的Element的子类 ObjectStructure 提供一个高层接口,允许访问者访问Element的子类.,提供一个访问列表 使用访问者模式的情况 当一个对象的结构中,包含有多种类型的具有不同接口的对象,且用户要在这些对象上进行依赖于具体的类的运算 当有多个不同的并且互不相关的运算将作用域这些对象上,且用户不希望这些运算混淆这些类时 当对象的数据类型很少改变,但需要经常改变操作或增加新操作的情况下. 状态模式将不同状态下的行为封装在不同的类中,每个类代表一个状态 使用场景: 当一个类依赖于状态,那么程序员在描述该对象的类中通常会使用很多条件语句,这时,使用状态模式可以有效消除条件语句并使得状态转换非常清楚 GANG OF FOUR的定义:允许一个对象在其内部状态改变时,改变其行为.这个对象看起来似乎修改了它的类类图 各组件描述: Context:定义了和客户程序的接口,它保持了一个ConcreteState的代表现在状态的实例 State:状态接口,子类封装各个状态下行为ConcreteState:State的子类 使用状态模式的情况 对象的行为依赖于状态,对象再运行时改变状态 操作有大量依赖于状态的条件语句 优点 容易添加新的状态(因为封装在子类), 状态迁移很明确 桥接模式将对象的继承转为对象的组合将一个软件设计的抽象部分和实现部分分离,使它们都可以独立地变化.类图 各部分解释 Abstraction接口,定义抽象部分的接口,为吃Implementor对象的一个参考 RefinedAbstraction,继承或者实现Abstraction Implementor:定义Implementation类的接口,接口形式可以不和Abstraction界面严格对应 ConcreteImplementor:实现Implementor接口 优点 分离接口和实现部分, 提高了可扩展性 实现了细节对客户的透明 适配器模式目的:解决接口不一致 分为类适配器模式和对象适配器模式 类图 类适配器: 写一个target接口声明所有需要的方法,写一个adaptor类继承adapee类,并且实现接口target 对象适配器:写一个target接口声明所有需要的方法,采用聚合的方法来实现adaptee类中的方法 使用适配器模式的情况 想要使用现有的类,但现有类的接口不符合需求 当需要通过创建一个可服用的类,是的本来接口不相容且无关的类结合在一起工作时 在设计中需要改变多个子类接口,在作用相同但名称不同的类或方法之间进行适配时. MVC 视图：管理作为位图展示到屏幕上的图形和文字输出； 控制器：翻译用户的输入并依照用户的输入操作模型和视图； 模型：管理应用的行为和数据，响应数据请求（经常来自视图）和更新状态的指令（经常来自控制器）； 如果用户通过一个View的Controller改变了Model,所有其他的View都必须反映出该改变. 当数据发生变化的时候,Model负责通知所有的View,告诉他们数据已经改变了","link":"/2021/12/07/2021-12-07-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"title":"21&#x2F;12&#x2F;6 软件体系结构复习","text":"复习1.基本概念软件体系结构系统的基本组织结构,包括系统构成要素,这些构成要素之间以及与环境之间的关系,系统设计及演化时所应遵循的原则 什么设计模式?是一套被反复使用,多数人知晓的,经过分类编目的,代码设计经验的总结.为什么要用设计模式?为了&lt;u&gt;可重用代码&lt;/u&gt;,让代码更容易&lt;u&gt;被他人理解&lt;/u&gt;,保证&lt;u&gt;代码可靠性&lt;/u&gt; 非功能需求有哪些?,含义是什么? 性能 可扩展性/伸缩性 可维护性 可用性 安全性 业务质量成本,周期,投入的人力,需要的资源 性能需求:用户在软件响应速度,结果精度,运行时资源消耗量等方面的要求 可靠性需求:用户在软件失效的频率,严重程度,易恢复性,以及故障可预测性等方面的要求 易用性要求:用户要求在界面的易用性,美观性,以及对面向用户的文档和培训资料等方面的要求 安全性需求:用户在身份认证,授权控制,私密性等方面的要求 运行环境约束:用户对软件系统运行环境的要求 外部接口:用户对待开发的软件系统与其他软件系统或硬件设备之间的接口的要求 可保障性要求:用户在软件可配置性,可扩展性,可维护性,可移植性方面的要求 编程的三个层次?针对实现编程 Dog d = new Dog(); d.bark(); 针对接口/超类型编程 Animal animal = new Dog(); animal.makeSound(); 运行时才指定具体实现的对象 a=getAnimal(); a.makeSound(); 设计模式的三大原则单一职责一个类只负责一个功能领域中相应的职责, 依赖倒置针对接口编程,而非针对实现编程 即程序中所有的依赖关系都是终止与抽象类或者直接接口. 开闭原则对拓展开放,对修改关闭 面向对象的三大原则软件体系结构分层风格指将软件设计成层次结构,每个层为其上层服务,同时又是其下层的客户,不允许隔层调用 优点 层次结构 支持基于随着层次不断增加而不断抽象的设计.能将一个复杂的问题分一系列从初等的与硬件相关的功能到可以被用户使用的高级功能. 支持更新.每层只和两个层交互,因此,在接口不变的前提下,可以单独修改或更换某一层的某些组件而不影响其他层. 支持复用. 缺点 不是什么系统都容易被组织成层次结构 有时层次结构的逻辑上的较高层级和较低层级会有比较紧密的耦合 正确的层次抽象往往可能很困难. 管道-过滤器风格每个过滤器都有一组输入和输出,组件读入输入数据流,经过数据处理,然后产生输出数据流. 系统由负责运送数据的管道和负责对数据进行处理的过滤器组成 优点 高内聚低耦合 允许设计者将整个系统的输入/输出行为看做是多个过滤器行为的简单合成 支持软件重用 系统维护和增强系统性能简单 允许对一些如吞吐量,死锁等属性的分析 支持并发 缺点 导致进程称为批处理结构 不适合处理交互应用 因为每个过滤器上都增加了解析和合成数据的工作,因此系统性能下滑, 主程序-子程序风格采取分而治之策略,将一个复杂的问题分解为多个独立的字问题 自顶向下功能化设计思想(结构化设计)从功能需求出发,将一个整体问题分解为多个子问题,然后将子问题划分为几个更小的子问题,直到不可划分为止 优点 逻辑设计与物理设计分开 开发过程中形成一套规范化的文档,以便后期修改和维护 适用于组织相对稳定,业务处理过程规范,需求明确且在一定时期内不会发生大的变化的大型复杂系统的开发. 缺点:开发周期长,系统难以适应环境的变化及开发过程复杂繁琐 功能演化困难,显示中的系统功能不容易描述,功能化设计丢掉了数据与数据结构,产生的可复用代码少. 面向对象软件体系结构系统看做由一些对象的集合构成,消息从一个对象发送到另外一个对象.每个对象都有其相关的功能 对象是一个具有状态和行为的实体.一个对象存储它的状态在域中,面向对象设计隐藏对象的内部状态,并且要求所有对象之间的交互都通过该对象的方法,这叫做数据封装,是面向对象编程的基本原则. 面向对象设计的特点 封装性,限制对特定信息的访问 继承性,共享同一个功能定义 动态绑定性:在程序运行前,不知道创建哪个类的对象,运行时才动态生成 复用和可维护性:因为封装与局部化 系统功能通过对象服务表示:对象的接口提供了一系列的方法. 共享数据区域被取消 对象可以是分布的.通过函数或者方法调用互相交互. 对象是对现实世界的抽象并且可以自己管理自己. 优缺点 优点: 容易维护 可复用性好 映射现实世界 容易对一个系统进行剖分 缺点 占用欧冠内存较大.因为每个新被创建的对象都必须占用一块内存,而面向对象程序中,往往有大量对象被创建 一个对象要和另外一个对象交互,该对象必须知道另外一个对象的身份,包括对象名,方法名和参数类型等. 基于共享数据的事件风格 系统中的每个组件可以注册一种事件 当一个组件要发布事件时,该组件可以广播一个或多个事件到事件空间 每当一个事件被广播了,系统将负责自动调用那些已经注册了该事件的组件或者过程,被调用的组件将运行. 2.设计模式mvc模式model 包含核心数据和功能,独立于输入行为和输出表示 View 将模型中的数据显示给用户 Controller处理用户输入,如果用户通过一个view 的controller改变了model,其他controller必须反映出该改变,即当数据发生变化的时候,model负责同志所有的view,告诉他们数据已经改变了.(观察者模式,model对象是被观察者,controller是观察者) 优缺点优点 对于同一个模型,可以有不同的视图和控制器,一遍提供给用户不同类型的用户图形界面 改变-传播机制保证了模型在改变的同时自动刷新所有的视图 mvc体系结构的设计使的改变图形界面非常容易,适合业务逻辑较少改变,而图形界面需要经常改变的应用 全部的核心数据和核心功能都包含在模型中,很容易对核心的应用进行测试 可拓展性比较好 命令模式三个部件 客户程序 调用者程序 被调用者程序 解除调用者类与被调用者类的耦合–为响应客户新请求的行动创建一个抽象 client对象负责初始化Command对象,并且提供将来要调用的方法的全部信息 Invoker决定什么时候调用所要调用的方法 receiver是含有索要调用方法的代码的实例 3.期末复习","link":"/2021/12/07/2021-12-07-%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/"},{"title":"计网笔记-数据链路层","text":"12_2_数据链路层1. 数据链路层的基本功能&lt;u&gt;将数据报从一个节点经过一条链路传输到相邻节点&lt;/u&gt; 组帧:将数据报封装进帧，加上首部和尾部 链路接入:如果共享媒体，控制信道接入,使用帧首部中的“MAC”地址标识源和目的地 相邻节点间的可靠交付, 检错 纠错:接收方识别并纠正比特差错，而不需要重传 它放在哪?适配器(网卡),和主机系统总线相连 2.差错控制通过通信信道接收的数据与发送的数据不一致的现象称为传输差错(简称差错)。 2.1检错编码2.1.1单比特奇偶校验奇偶校验码是一种通过增加冗余位使得码字中“1”的个数恒为奇数或偶数的编码方法 能力:能够检测单(奇数)个比特差错 2.1.2InternetChecksum–UDP里讲过2.1.3循环冗余校验原始数据:D 校验位:长度r, 原始数据后补上r位0, Generator: G:r+1的长度 D不断异或G(其实是求余数),最后剩下的为校验位 检测能力 2.1.4二维奇偶校验二维奇偶校验能够检测并纠正单比特差错 2.2纠错编码3.介质访问控制点对点/广播 3.1信道划分将信道划分为较小的“片” (时隙，频率，编码) 为节点分配专用的片 3.1.1频分多路复用3.2.2时分多路复用、3.1.3波分多路复用3.1.4码分多路访问3.2随机访问不划分信道，允许冲突 从“冲突”中恢复 3.2.1ALOHA协议、CSMA协议、 传播时延的冲突: 传播时延:传输距离/光速 端到端往返时延 2t 称为争用期，或冲突窗口 3.2.2CSMA/CD协议需要在发送完帧之前就能收到自己发送出去的数据，即帧的传输时延至少是数据在总线中的传播时延的2倍 最小帧长=传播时延* 2 *数据传输速率 例如，以太网的冲突窗口长度为51.2µs，数据传输速 率为10Mbps，51.2µs可以发送512bit（64B）数据，因 此，64B是以太网的最短帧长度； 、CSMA/CA协议3.3轮流协议3.3.1令牌传递协议3.3.2轮询协议4.局域网4.1局域网的基本概念与体系结构4.2局域网寻址与ARP协议4.3以太网与IEEE 802.34.3.1以太网拓扑结构90年代前:总线型拓扑(单冲突域) 现在星形(中心是交换机,节点之间不冲突,不需要CSMA) 4.3.2以太网帧结构 … 4.3.3 以太网属性 •connectionless: no handshaking between sending and receiving NICs 连接之间没有握手 •unreliable: receiving NIC doesn’t send ACKs or NAKs to sending NIC 就是说,如果没收到就直接扔了,不发消息 以太网的MAC Control CMSA/CD+指数回避(用来防止连续冲突) 4.4无线局域网(IEEE 802.11)4.4.1典型结构 4.4.2冲突控制 CSMA/C(ollision)A(voidance) 允许发送端预订信道 发送端发送请求帧到AP AP广播允许发送(CTS)的回复 所有结点收到CTS,发送端发送 5.数据链路层设备5.1局域网交换机查看进入的MAC地址,然后转发给出链路 **&lt;u&gt;透明&lt;/u&gt;因此在转发的时候分组里&lt;u&gt;不会&lt;/u&gt;**有交换机的物理地址 &lt;u&gt;自学习&lt;/u&gt;: 收到对应接口分组后记录对应接口MAC地址在自己对应接口上 如果发现目的接口没有,会洪泛(将分组分发到所有接口上,等待回复) 5.2 冲突域vs广播域 冲突域 当两个设备在同时发送分组的时候会冲突 下面每个圈都是冲突域 广播 通过广播能发到的一堆设备 虚拟局域网(为了防止过多的广播信息引起不便) 虚拟局域网VLAN是由一些局域网网段构成的与物理位置无关的逻辑组 每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的工作站是属于哪一个 VLAN。(在以太网帧中插入一个4字节的标识符,称为VLAN标记)","link":"/2021/12/09/2021-12-09-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"title":"网络地址转换","text":"网络地址转换目的:解决ip稀缺 三个专用地址块 原理:本地网络中的所有计算机在访问Internet时使用同一个IP地址，within the local network, computers use private addresses forrouting intramural traffic在本地网络中，计算机使用专用地址进行路由。对于目的地址是专用地址的数据报，路由器一律不予转发。 本质:通过端口号区分主机 IPV6同样是为了改变缺少ip地址的问题 源ip:128位 目的ip:128位 隧道技术解决ipv4和ipv6共存 ipv6作为ipv4的payload(数据)发送","link":"/2021/12/09/2021-12-09-%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/"},{"title":"网络层","text":"网络层-控制平面路由算法产生路由表的算法图论抽象Graph: G = (N,E) N = set of routers = { u, v, w, x, y, z } 节点是路由器 E = set of links ={ (u,v), (u,x), (v,x), (v,w), (x,w), (x,y), (w,y), (w,z), (y,z) } 边是物理链路 链路开销Cost of link：时延、费用或拥塞等级 路径开销Cost of path：c(x1 , x2 , x3 ,…, xp ) = c(x1 ,x2 ) + c(x2 ,x3 ) + … + c(xp-1 ,xp ) 路由算法：找到开销最小的路径(路由器序列) 分散式算法–只知道和部分路径,通过和邻居交换信息 典型就是下面这个算法 • 距离向量路由算法描述 节点x维护距离向量 Dx=[dx (y): yєN ](如果y不是x的邻居节点, 则dx (y)=∞,否则dx (y)= c(x,y)) 每个节点周期性向其邻居节点发送它自己的 距离向量, 节点x保存其邻居节点的距离向量Dv = [dv (y): y є N ] n当节点x接收到来自邻居的 新距离向量，它使用B-F方程更新自己的DV :Dx (y) ← minv {c(x,v) + Dv (y)} for each node y ∊ NBellman-Ford方程： 定义$d_x$ (y) = 从x到y的最小开销路径的开销,c(x,v) = 从x到邻居节点v的链路的开销 则dx (y) = minv {c(x,v) + dv (y) } 取值最小的节点对应最短路径中的下一跳(只有一个地址)➜ 转发表 示例&lt;img src=&quot;https://s2.loli.net/2021/12/09/HhICGUakqft2zm1.png&quot; alt=&quot;image-20211122134953146&quot; style=&quot;zoom:50%;&quot; /&gt; • 链路状态路由算法 • Discover its neighbors, learn their network address. 发现邻居，学习它们的网络地址 Measure the delay or cost to each of its neighbors. 测量到每一个邻居的时延或开销 Construct a packet (link state packet)telling all it has just learned. 构造一个分组(链路状态分组) 来通 告其学习到的所有信息 Send this packet to all other routers. 向所有路由器发送该分组 Compute the shortest path to every other router. 计算到其他路由器的最短路径使用Dijkstra算法计算最短路径&lt;img src=&quot;https://s2.loli.net/2021/12/09/mCdF4G2wO7vxpUW.png&quot; alt=&quot;image-20211122143134224&quot; style=&quot;zoom:50%;&quot; /&gt; 路由协议受到分组压力,单位需求的影响,产生了as(自治系统) 系统内可以用之前的算法,系统外–?自治系统间专门的路由协议 • O(pen)S(hortest)P(ath)F(irst)路由协议自治系统内路由-开放最短路径优先使用的算法是链路状态算法OSPF的特点 安全性–报文经过签名鉴别 使用多条开销相同的路径 对每条链路,为不同的服务类型设置多种开销度量 集成的单播和多播支持 层次ospf自治系统内进一步再分 • BGP路由协议(border gateway protocol)-自治系统间路由算法-距离向量算法(改名—路径向量算法) eBGP: Obtain subnet reachability information from neighboring ASes.从相邻AS获得子网可达性信息 iBGP: Propagate reachability information to all AS-internal routers. 向AS内部的所有路由器传播可达性信息 Determine “good” routes to subnets based on reachability information and policy.根据可达性信息和策略，决定到子网 的“好”路由 •ICMP-The Internet Control差错报告–不可达网络\\主机\\端口\\协议 回声请求 trace route 源主机从ttl=1,一点点开始发送更大的ttl,目的端口号设置为一个不可能到达的端口, 当ttl超时时,该路由器发送一个ICMP报文到源主机,这样会获取路径上路由器的信息 到达目的主机后,会返回一个端口不可达报文,探测结束 Message Protocol•网络管理——SNMP协议","link":"/2021/12/09/2021-12-09-%E8%AE%A1%E7%BD%91%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"title":"文件系统-操作系统","text":"文件系统文件管理文件系统的功能支持文件所占存储介质空间的分配/回收支持文件相对起始数据的逻辑块定位到外存上的物理块支持对文件访问的安全检查支持对文件的读写访问 文件的结构逻辑结构(文件组织):用户看到的文件组织形式,和存储:设备无关 有结构的记录式文件：由一个以上的记录构成 无结构的流式文件：文件没有结构，由一串字符流构成 物理结构:外存上存放形式,和存储设备特性有很大关系 文件存储器物理特性:•磁带 顺序访问设备→要求文件顺序存放于带上。 •磁盘 直接（随机）访问设备→文件可顺序、链接式或随机（通过类似页表的索引结构访问）存放于设备上 文件系统重要作用(之一)在用户逻辑文件和物理文件之间建立映射 文件存取方式读写文件存储器上的一个物理块的方法 顺序存取：指对文件中的信息按顺序依次读写 随机存取法: **直接存取法：允许用户随意存取文件中任意一个物理记录** **按键存取法：根据文件中各记录的某个数据项内容来存取记录的，这种数据项称之为键** 几种常见的物理存储方式1. 连续存储(顺序结构)它将逻辑上连续的文件信息依次存放在编号连续的物理块上。 l优点： –存储方式简单。 –对文件记录进行批量存取时，其存取效率较高。 –支持定长记录的直接存取，可以通过计算获得存储位置。 l缺点： –不支持随机查找。如果要随机地查找或修改单个记录，此时系统需要逐个地查找诸记录，性能较差，尤其是当文件较大时情况将更为严重。 –存在外部碎片。 –不便于记录的增加或删除操作。 –链接结构 •将逻辑上连续的文件信息存放在不连续的物理块上，每个物理块设有一个指针指向下一个物理块。 l优点： –提高了磁盘空间利用率，不存在外部碎片问题。 –有利于文件插入和删除，及其动态扩充。 l缺点： –仍然不支持随机查找。 –由于存储空间可能不连续，带来更多的寻道次数和寻道时间。 –需要牺牲一些空间存放链接指针，同时需要维护这些指针，增加了系统开销。 –可靠性问题，如指针出错。 索引结构将逻辑上连续的文件信息(记录)存放在不连续的物理块中，系统为每个文件建立一个专用数据结构——索引表，索引表中存放文件的逻辑块号和物理块号的对应关系 优点：既能顺序存取,又能直接存取。满足了文件动态增长、插入删除的要求。没有外碎片，外存空间利用率较高。缺点较多的寻道次数和寻道时间。索引表本身需要存储空间，同时对索引表的维护会增加系统开销。 索引表组织方式 链接文件方式：将多个索引表块按链接文件的方式串联起来 多重索引方式：将一个大文件的所有索引表（二级索引)的地址放在另一个索引表（一级索引)中。 多重索引优势 寻址空间较大,相比于链接文件,会大大减少读取对应物理块所需要的读盘次数(因为要从文件中读取索引项) 文件的目录OS观点：文件包含文件控制块和文件体 文件控制块（FCB）的主要内容： 文件名创建者文件物理位置信息：如索引表创建、修改时间、保存时间口令：用于对文件访问进行验证操作限制：如读、写、执行权限说明 文件目录提供的功能： 实现“按名存取”。用户只须提供文件名，即可对文件进行存取。这是文件系统向用户提供的最基本的服务。提高对目录的检索速度。合理地组织目录结构，加快对目录的检索速度，从而加快对文件的存取速度。这是在设计一个大、中型文件系统时，所追求的主要目标。实现文件共享。在多用户系统中，应允许多个用户共享一个文件，以节省大量的存储空间并方便用户。解决文件重名问题。系统应允许不同用户对不同文件采用相同的名字，以便于用户按照自己的习惯命名和使用文件。 文件目录结构l一级目录结构 为外存上的全部文件设立一张平面（flat）的目录表，包含所有文件的FCB。每建立一个新文件即在目录中增加一个FCB，每当删除一个文件即抹去对应的FCB，当要访问一个文件时，先按文件名在目录中找到对应的文件FCB。为了快速查找到文件FCB，可按文件名进行Hash，或其它快速查找方式 优点：简单缺点：1、查找速度慢2、不允许重名3、不便于实现文件共享 l二级目录结构 设一个主目录MFD，为系统的每个用户设用户目录UFD，用户目录是用户所有文件FCB的集合，主目录中存放每个用户目录的用户目录名和UFD的索引表等（当我们把UFD看作是一个文件时，这个文件的内容是用户所有文件FCB集合，MFD中则包含每个UFD文件的FCB 路径名将用户名与文件名连到一起组成路径名。例如：/songhong/test.c 多级目录——树形目录结构 树状的多级目录结构任何一级目录中的FCB既可以描述次一级的子目录，又可以描述一个文件 特点: 利于文件分类，从文件路径名可看出文件类别。查找文件FCB耗费时间，要得到文件FCB，必须从根查起。唯一确定文件的路径名太长，故引入当前目录 概念，提供相对于当前目录的相对路径名可加速文件FCB的查找，进程控制块存有当前目录信息 访问 必须指出文件所在路径名：从根目录到该文件的路径上各级目录名的组合。也称为文件全名。例如：/usr/lib/man相对路径：设置一个“当前目录”(也叫“工作目录”)，此时对于文件的查找是从当前目录中进行的。可以带来两点好处：用户使用更加方便检索效率更高 优缺点 l树形多级目录结构的优点 •提高了检索目录的速度。 •较好地解决了重名问题。 l缺点 不便于用户共享文件 无环图目录结构当一个文件副本可以同时属于两个不同目录（类别）时，即同一个文件有二条路径名，或多条路径名时出现无环图目录结构。特点：方便文件共享，分类。两个或多个FCB的一致性难保证，因此将FCB独立存放，引入带文件/目录名和FCB指针的目录项 文件共享 硬链接(hard link) 指向同一个索引结点 符号链接 建立符号链文件,该文件内容为要访问文件的路径名 文件存储器空间布局与管理空闲区表 位示图 空闲块链","link":"/2021/12/07/2021-12-07/"},{"title":"计算机网络复习","text":"计网复习大纲[toc] 1. 计算机网络体系结构1.1 计算机网络概述1.1.1计算机网络的概念、组成概念 计算机网络就是通过交换机,路由器等网络设备和通信线路将分散在不同地理位置的多个计算机系统连接起来,在网络协议和应用软件的控制下实现各种网络服务的系统. 资源共享-最终目的 数据通信-资源共享的前提 网络的结构 网络边缘(network edge)-服务端和客户端 服务端功能:发送分组数据 收到应用数据-&gt;拆解为小组块-&gt;以R传输速率(带宽bandwidth)进行传输 传输延迟$L_{比特数}/R_{传输速率}$ 接入网络(access networks)-物理介质 物理层: 发送端和接收端之间 导引型介质(guided media) 固体介质-铜线,光纤(optical fiber),同轴电缆(coaxial cable) 双绞线:螺旋排列减小电磁干扰 同轴电缆:单信道/多信道 光纤:光脉冲,低差错率,无电磁干扰 非导引型介质(unguided media) 自由发信号 e.g. 无线电 网络核心(network core)-互联的路由器 路由器网络 分组交换 主机把报文分解成分组 网络核心转发分组(从源头到目的)- 单个分组传输到相邻节点，存储下来后查转发表，转发到下一节点。 1.1.2计算机网络的分类 Transmission technology传输技术广播链路 点到点链路 Scale距离尺度局域网LAN 101km城域网MAN 1km10km广域网WAN 100km~ Topology拓扑结构星形什么的,看名字就知道了 Switching交换 Packet Switching 分组交换 Circuit Switching 电路交换 1.1.3计算机网络与互联网的发展历史[不考]1961-1972: Early packet-switching principles 分组交换的发展 1972-1980: Internetworking, new and proprietary nets网络互联.专用网络1980-1990: new protocols, a proliferation of networks网络的激增1990, 2000’s: commercialization, the Web, new apps 商业化 2005-present 1.1.4计算机网络的标准化工作及相关组织[不考]IETF(因特网工程任务组) IEEE802-局域网/城域网标准委员会,指定相关标准 1.2计算机网络体系结构与参考模型1.2.1计算机网络分层结构1.2.2计算机网络协议、接口、服务等概念服务: 层的功能 协议: 同一层的对等实体间的交流服务 接口: 告诉上层如何访问 1.2.3ISO/OSI参考模型和TCP/IP模型ISO/OSI 参考模型 ISO: international Standards Organization OSI: Open Systems Interconnection • application: 支持网络应用• presentation:允许应用程序解释数据的意义，如加密、压缩• session: 数据交换的同步，检查和恢复• transport:进程到进程的数据传输(端到端)• network:为数据报选择从源主机到目的主机 的路径• data link:在邻近网元之间传输数据 • physical:在介质上传输原始比特 TCP/IP 参考模型 协议栈 下图左为OSI,右为TCP/IP 混合模型(Hybrid Model) 本课程使用的模型 传世经典(bushi)-数据传输过程中在各层发生的变化 1.3计算机网络性能指标吞吐量Throughput-传输位数/传输时间 带宽是吞吐量的绝对上限 带宽 Bandwidth 在单位时间内,从网络中的某一点到另一点所能通过的位数 时延/延迟 Delay 一个数据库从网络的一端传送到另一端所需要的时间 时延=处理时延+排队时延+传输时延+传播时延 传输时延-数据量/带宽 传播时延-传输距离/光速 往返时延(RTT)-从发送端发出,到发送端收到接收端的确认的总时延 端到端时延-分组从源主机到目的主机路径上每个节点时延的总和 时延带宽积-传播时延*带宽 2. 应用层2.1 应用层协议原理2.1.1网络应用程序的体系结构Client-Server(C/S)server: 永远在线 永久ip 服务器集群增强可扩展性 client 与服务器交互 动态IP地址 客户机之间不直接通信 Peer-to-Peer(P2P) 没有长期存在的服务端 端系统之间直接通信 对等方向其他对等方(Peer)请求服务,同时给其他peer提供服务 对等方间歇性连接,IP可变 2.1.2可供应用层使用的传输层服务app需要什么? 数据完整性 吞吐量 时效性 安全性 TCP 提供 面向连接 可靠传输 流量控制 拥塞控制 不提供 定时(时效性) 最小带宽保证 UDP 不可靠数据传输 不提供 流量控制 连接建立 可靠性 拥塞控制 时效性 最小带宽保证 因特网使用的应用层协议和传输层协议 2.2应用层协议2.2.1Web和HTTPhttp:超文本传输协议 使用TCP协议 客户端初始化传输端口,发送给服务端 服务端接受连接请求 交换信息 连接关闭 非持久http: 每个连接只发送一个对象(HTTP/1.0) 例子 持久http:每个连接发送多个对象(HTTP/1.1) 过程 客户端初始化连接 服务端接受 下面步骤*n 客户端发送请求 服务端发送数据 客户端收到数据 服务端关掉连接 例子 HTTP请求报文两种type: 请求和响应 请求报文样式: 请求行 报头 空白行 正文 GET /somedir/page.html HTTP/1.1 –请求 Host: www.someschool.edu User-agent: Mozilla/4.0 Connection: close Accept-language:fr–报头 无状态(Statelessness)和Cookies无状态-服务器不保留有关客户过去请求的任何信息 Cookies 一个小文件/字符串,使得服务端能够跟踪用户 实现 在Http响应报文上加上set-cookie头 请求报文上加入cookie报头 cookie文件留在用户本地,用浏览器管理 在服务端留有后端的服务器存储用户真正信息 Web缓存 -代理服务器目的:缩短对客户请求的响应时间,减少组织接入链路上的流量 用户浏览器:通过缓存访问网站 浏览器把所有的HTTP响应发送给cache 条件GET如果缓存中有最新缓存版本,就不发送该对象 2.2.2FTP[不考]2.2.3Electronic Mail——SMTP, POP3, IMAP关键组件: 用户代理 邮件阅读者 撰写,编辑,阅读邮件 发送/接收在server上存储的邮件 邮件服务器 mailbox 保留用户收到的信息 为发送的邮件信息创建发送队列 在server中间提供SMTP协议服务,用来发送邮件 示意图 邮件发送协议: SMTP:简单邮件传输协议 MIME:通用因特网邮件拓展SMTP只能传输ASCII码,不能传输二进制数据,MIME允许二进制数据以ASCII编码 邮件读取协议: pop:邮局协议 Post Office Protocol授权+下载 IMAP:因特网报文读取协议更多功能操作存储在服务器上的报文 HTTP: gmail,Hotmail,Yahoo!Mail 2.2.4DNS 域名系统提供的服务 主机名到ip的翻译 主机别名 邮件服务器错误识别 负载分配(即一个主机名对应一组IP地址) 分布式层次化数据库 访问www.amazon.com的过程 客户-&gt;root,得到com server 客户-&gt;com server 得到 amazon.com DNS server 客户-&gt;amazon.com DNS server 得到对应ip地址 本地域名服务器大学/公司内部搭建 主机创建DNS请求的时候,先送到本地DNS server 域名解析例子DNS Protocol使用UDP协议的53号端口传输 2.2.5P2P[不考]2.3网络编程[不考]网络应用程序编程接口-套接字[不考]3.传输层3.1传输层提供的服务3.1.1传输层的功能为运行在不同主机上的应用进程之间提供逻辑通信 端到端 依赖并强化网络层服务 3.1.2无连接服务与面向连接服务无连接:无握手 面向连接:数据交换前通过握手初始化发送方与接收方的服务 3.1.3传输层寻址与端口传输层寻址通过TCP和UDP的端口实现 TCP/IP:0~65535 0~ 1023:标准端口,用于特定服务 其余临时端口 不同的端口表示不同的应用程序 3.2无连接的传输协议——UDP特征 尽力而为(会丢包,顺序会乱) 无连接-没有握手,每个报文的处理与其他报文独立 经常被流媒体使用(能容忍丢包,对时间敏感) DNS和SNMP是用UDP的 UDP格式 源端口(16bit 目的端口(16bit) 长度(16bit) 校验和(16bit) 报文 UDP校验和计算 临时把伪首部(12字节IP首部)和数据报连接在一起,用于检验是否在正确的端点之间传送 计算校验和 过程 反码求和 校验和例子 3.3可靠数据传输的原理目的 数据位不被损坏 没有数据丢失 数据以发送顺序被传输 总结-要在非可靠信道上提供可靠的数据通信 基础操作 ARQ自动重传请求:接收方发现错误/丢失分组后要求发送方重传 错误分组检测-校验和 丢失分组-确认,超时 重传(Retransmit) 3.3.1停止-等待协议（SW）发送方发送一个分组后,必须停下来等待接收方确认后才可以发送下一个分组 错误处理:收到错误分组,接收方发送否定确认,让发送方重发 丢失处理:发送方内部设置定时器,超过定时时间还未收到ACK确认,则重发 处理重复分组:给每个分组带上序号(模$2^n$) 性能分析及计算 3.3.2回退N协议（GBN）发送方 在收到确认前可以发送多个分组 发送窗口$W_s$最大为$2^n-1$ 每发送一个分组后,就启动内部计时器,若超时未收到确认,则重发该分组之后已发送的N个分组 接收方 接收方只能缓冲一个分组 接收方只对按序到达的最后一个分组发送确认分组(因此对乱序分组会产生重复的确认分组) 序号: 是模2^n的,n是字段的位数 3.3.3选择重传协议（SR）避免不必要的重传 接收方 接逐个确认接收到的每一个分组 发现某个分组出错后,其后继续送来的正确分组还是被接收,放在缓冲区中,同时要求发送方重新传送出错分组 发送方 只有在接收窗口向前滑动时,发送窗口才有可能向前滑动 即$W_S&gt;=W_R$ 且 $W_s+W_R&lt;=2^n$ 窗口长度&lt;=$2^{n-1}$ 3.3.4滑动窗口机制（可用于实现不同可靠传输协议）流水线协议/连续ARQ(也叫&lt;u&gt;滑动窗口协议&lt;/u&gt;) 当发送端等待确认时,我们需要传输多个分组来提高利用率 Pipeling: 允许发送方发送多个未被确认的分组 概念 发送窗口: 发送方在没收到确认的情况下,能够连续发送的分组的序号表&lt;img src=&quot;https://s2.loli.net/2021/12/10/wgjTx5c3aqrCoHD.png&quot; alt=&quot;image-20211210191530175&quot; style=&quot;zoom:50%;&quot; /&gt; 大小:$W_s$ 下界表示未得到确认的分组的最小序号 接收窗口: 希望接收的分组的序号表 大小$W_R$ 上界表示允许接收的分组的最大序号,下界表示希望接收的下一个分组的序号 若序号等于下界的分组被正确接收,并发送一个确认分组,上下界都加1,接收窗口向前滑动一次 3.4面向连接的传输协议—— TCP总览 点到点 可靠有序的字节流-没有报文边界 流水线-拥塞控制和流量控制设置窗口大小 全双工数据-双方可以同时发送和接收 要求每一端都有两个窗口 流量控制 面向连接 拥塞控制 3.4.1TCP报文段结构 解释 源端口和目的端口-2字节/each, 序号-每字节都有序号,序号字段存储发送字节的第一个的序号 确认号-希望收到下一个保温段的数据的第一个字节的序号TCP使用累积确认 一些特殊位 URG-紧急 ACK-1时确认号字段有效 PSH-尽快交付(不等待缓存写满) RST-reset 复位,重新建立连接 SYN-如果为1表示这是个连接请求 FIN-1的话释放连接 校验和-检验首部和数据 3.4.2TCP可靠传输用字节序号进行控制 过程模拟 B给出通告窗口值20-&gt;A构造长为20的发送窗口(31~50) A发送11字节数据,此时还剩9字节可被发送 B接收窗口也为20,收到3字节,发送确认号33-&gt;A窗口移动到(34~53) B窗口也滑动到34 重传计时器*** 四个窗口(两发两收)动态变化 3.4.3TCP流量控制目的:让发送方速率不要太快,让接收方来得及接收 利用滑动窗口机制实现 如果接收端顶不住发送端了,缓冲区被全部占用,就只能发送一个零通告窗口 发送端收到零通告窗口后停止发送,直到等到接收端发送一个非零的通告窗口 持续计时器收到零通告窗口时启动,如果持续时间到期,就发送一个探测报文段,请求一个对方的通告窗口如果还是零,就重设计时器 3.4.4TCP连接管理[不考]3.4.5TCP拥塞控制太多的源太快地发送太多的数据,使网络来不及处理 表现:丢包(路由器缓冲区溢出) 长时延(缓冲区中排队) 作用: 提高吞吐量 与流量控制的区别 拥塞控制 需要确保通信子网能够承载用户提交的通信两,是一个全局性过程,涉及主机,路由器等很多因素 流量控制 与点到点的通信量有关,主要解决快速发送方与慢速发送方的问题,是局部过程 拥塞控制方法发送方维持一个拥塞窗口cwnd,其大小取决于网络拥塞程度,且动态变化 网络不堵塞,拥塞窗口增大一些 堵塞就把它减少一些 发送方发送窗口的上限为接收方通告窗口[rwnd]和拥塞窗口[cwnd]中较小的一个 四种办法 慢开始/启动cwnd初始化为1每收到一个对应确认,cwnd+=1每经过一个传输轮次,cwnd*=2,时间为RTT 拥塞避免每经过一个RTT,拥塞窗口+1,缓慢增长 慢开始门限ssthresh cwnd&lt;ssthresh -&gt;慢开始/慢启动算法 cwnd&gt;ssthresh -&gt;拥塞避免 cwnd=ssthresh -&gt;都行 实现举例&lt;img src=&quot;https://s2.loli.net/2021/12/10/rKaCnqT3tRbxd4m.png&quot; alt=&quot;image-20211210203723811&quot; style=&quot;zoom:50%;&quot; /&gt; 出现拥塞时 把ssthresh设置为当前值的一半 把cwnd重设为1 快重传要求接收方每收到一个失序的报文段后立即发出重复确认发送方一连收到三个重复确认就立即重传未收到报文段 快恢复当发送端收到连续三个重复确认时,把ssthresh设置为当前一半,但接下去不执行慢开始/慢启动算法,而是将cwnd设置为ssthresh减半后数值,然后开始执行拥塞避免算法&lt;img src=&quot;https://s2.loli.net/2021/12/10/3oTXGBk4VdvAQuf.png&quot; alt=&quot;image-20211210204852460&quot; style=&quot;zoom:67%;&quot; /&gt; 4.网络层4.1网络层的功能在发送端,将分组封装成数据报 在接收端,把数据报上传到传输层 路由器检查每个通过它的数据报 两个关键功能 转发-将分组从路由器的输入端口移动到输出端口 路由-决定分组从源主机到目的主机所采用的设备 网络层服务模型(我觉得没什么考的必要) 4.2网络层设备路由器输入端口 物理层-比特级接收 链路层连接以太网 最后一层进行分散式交换-给定数据报目的地址,在输入端口中使用转发表查找输出端口-到达较快的话还会排队 三种类型交换结构 输出端口 当数据报来自比传输速率更快的交换结构时,需要**&lt;u&gt;缓存&lt;/u&gt;** &lt;u&gt;调度安排&lt;/u&gt;-在排队的数据报中选择要传输的数据报 4.3IP链路层之上,传输层之下 4.3.1IPv4分组 首部字段解释 总长度-首部和数据之和的长度,最大为65535 标识-计数器,产生数据报标识 标志-3bit,最低位(M(ore)F(ragment)等于一代表还有分片,等于0代表没有分片,中间一位=0才允许分片(D(ont)F(ragment)) 片偏移-13bit,指出分片后该片在原分组中的相对位置,以8个字节为偏移单位 IP分片和重组为什么分片-链路有最大传输单元,不同链路MTU不同 样例 生存时间(TTL time to live) 限制数据报在网络中的生存时间,每经过一个路由器,TTL-1 协议-数据部分协议(TCP/UDP/IPV6等等)不一定是&lt;u&gt;上层,&lt;/u&gt; 首部校验和-只检验首部 4.3.2IPv4地址ip 地址-32位的主机/交换机标识号 接口interface-主机/路由器与物理链路之间的链接 交换机有很多个interface 主机一般就一两个 Ip地址与每个接口相关联 子网设备接口Ip地址的子网部分相同 可以物理上直接联系,不用经过交换机 计算可用的主机地址主机部分全0:网络地址 主机部分全1:广播地址 上两个不能设置为主机地址 子网掩码/n 表示子网掩码位数为n x.y.z.a,点分十进制形式表示32bit IP地址中哪些事子网部分 IP地址分配方案 子网位数固定-分类IP地址 不固定–CIDR(无类域间路由) 子网部分被称为网络前缀,前缀部分任意长 使用斜线记法 路由表中每个项目由”网络前缀” 和”下一跳地址”组成,查找路由表时可能会得到不止一个匹配结果,因此引出下面内容 最长前缀匹配举例 CIDR子网划分***把一个大网络分成多个小网络,用路由器把这些小网络连接起来 使用子网掩码255.255.255.192 (/26) 对网络192.168.10.0/24 进行子网划分，请回答如下问题 :– (1)子网数？ 192为二进制11000000，即 22 = 4 个子网； – (2)每个子网中可以容纳的主机数？ 26 -2 =62 个主机； – (3)哪些是合法的子网地址？ 每个子网的地址块大小为26 =64，子网地址的第4个字节从0开始以64递增，即：192.168.10.0、192.168.10.64、192.168.10.128、192.168.10.192 – (4)每个子网的广播地址？ – (5)哪些是合法的主机地址？ 子网地址 (192.168.10.) 0 64 128 192第一个主机地址 (192.168.10.) 1 65 129 193最后一个主机地址 (192.168.10.) 62 126 190 254广播地址 (192.168.10.) 63 127 191 255 4.3.3IP分组转发网络层基于目的地址分组转发 下图一了百了 转发算法 从收到分组的首部获得目的IP-&gt;D 判断是否在同一网络上 用子网掩码和D逐位相与,看看是不是和**&lt;u&gt;相应的网络地址&lt;/u&gt;**匹配,匹配就直接发过去 若路由表中有目的为D的特定主机路由,则将分组传送给指明的下一跳路由器,否则执行4 对路由表每行的子网掩码和D逐位相与,若结果与该行的目的网络地址匹配,就传送到下一跳否则,执行5 若路由表有默认路由,则将其传送给它,否则执行6 报告转发分组出错 4.3.4DHCP(动态主机配置协议)协议Q.A 主机如何获得IP地址 管理员硬编码 网络怎样得到IP地址的子网 从其ISP的地址空间中得到分配的部分 ISP如何获得地址块 ICANN(因特网名字与号码分配公司) DHCP目的: 使主机能够动态获取服务器的IP地址(当它加入网络时)示意图 4.3.5NAT[不考]4.3.6IPv6[不考]4.4路由算法 路由算法用于选择从源主机到目的主机的最佳路径 是产生路由表的算法(找到开销最小的路径) 分类 静态路由:路由随时间缓慢变化 动态路由:更快地变化,周期性更新,适应链路开销变化 4.4.1距离向量路由算法Bellman-Ford方程 定义$d_x(y)$=从x到y的最小开销路径的开销 $c(x,v)$=从x到邻居节点v的链路的开销 $d_x(y)=min_v{c(x,v)+d_v(y)}$ ,min针对x的所有邻居 取值最小的结点对应最短路径中的下一跳-&gt;转发表 过程 结点x维护距离向量$D_x=[d_x(y):y\\in N]$ 如果y不是x的邻居,则$d_x(y)=\\infin,否则d_x(y)=c(x,y)$ 每个节点周期性向邻居节点发送自己的距离向量,节点x保存其邻居节点的距离向量 当结点x收到来自邻居的新距离向量,它使用B-F方程更新自己的DV $D_x(y)\\gets min_v{c(x,v+D_v(y)} for each node y\\in N$ 示例 4.4.4链路状态路由算法 发现邻居,学习网络地址 测量到每一个邻居的时延 构造一个分组来通告学习到的信息 向所有路由器发哦送分组 计算到其他路由器的最短路径 使用Dijkstra算法计算最短路径循环: 从可达节点中找到最近的,加入当前节点组 更新其他节点距离 当当前节点组为全部节点时退出 4.5路由协议目的:使路由选择是可计算的 有巨量的router 构建自治系统自治系统内 OSPF自治系统间 BGP 4.5.1OSPF(Open Shortest Path First)开放最短路径优先 使用&lt;u&gt;链路状态算法&lt;/u&gt; 通告散布到整个自治系统 特点 安全性-所有OSPF信息经过鉴别 允许使用多条开销相同的路径 对每条链路,为不同的服务类型设置多种开销度量 集成的单播和多播支持 在大域中使用层次OSPF 层次OSPF 两级层次-本地+主干仅在本地通告链路状态每个节点具有详细的区域拓扑仅知道其他区域中网络的方向 区域边界路由器总结到自己区域中网络的距离,向其他区域的边界路由器通告 主干路由器在主干范围内运行OSPF路由 边界路由器连接到其他自治系统 报文格式 4.5.2BGPBorder Gateway Protocol边界网关协议 提供功能 eBGP:从相邻AS(自治系统)获得子网可达性信息 iBGP:向AS内部的所有路由器传播可达性信息如下图&lt;img src=&quot;https://s2.loli.net/2021/12/11/oJwg6KNUcvur8IY.png&quot; alt=&quot;image-20211211150833119&quot; style=&quot;zoom:50%;&quot; /&gt; 根据可达性信息和策略,决定到子网的”好”路由 允许子网向因特网其余部分通告它的存在 两个BGP路由器通过半永久TCP连接交换BGP报文 两个重要的属性 AS-PATH 4.6ICMP协议[不考]4.7SNMP协议[不考]5. 数据链路层5.1数据链路层的功能 将数据报从一个节点经过一条链路传输到相邻节点 组帧-将数据报封装进帧,加上首部和尾部 链路接入-控制信道接入 相邻节点间可靠交付 检错 纠错 5.2差错控制通过通信信道接收的数据和发送的数据不一致的现象-传输差错,简称差错 5.2.1检错编码检错 接收方能够推断发生了错误,要求重传 用于高可靠信道-光纤 单比特奇偶校验 增加冗余位使码字中1的个数恒为奇数/偶数 能够检测&lt;u&gt;奇数个&lt;/u&gt;比特差错 分为垂直奇偶校验和水平奇偶校验 因特网校验和 循环冗余校验直接看例子 5.2.2纠错编码[不考]纠错 接收方能够推断发送过来的原始数据是什么 用于易出错信道 二维奇偶校验-能够检测并纠正单比特 5.3介质访问控制5.3.1信道划分将信道划分为较小的片 时分多路复用TDM将时间划分为一段段等长的时分复用帧,每个用户在每个镇中占用固定序号的时隙 一目了然 频分多路复用FDM用户分配到频带后,在通信过程中始终占用该频带 不同用户同时间占用不同的(频率)带宽资源 波分多路复用WDM就是光纤上的频分多路复用 码分多路复用CDMA 用于无线广播信道中 为每个用户分配唯一的码型,所有用户共享相同的频率,但每个用户用自己的码片序列对数据进行编码 抗干扰/抗发现性较好 编码信号=(原始数据)X(码片序列) 解码 = 编码信号和码片序列的内积 码片序列每一比特时间划分为一个唯一的m bit 码片序列 要发送1,则发送码片序列发送0,则发送二进制反码 码片序列的正交关系两个不同站的码片序列正交 也就是说,二者规格化内积为0(每位相互乘累积后为0) 工作原理 5.3.2随机访问不划分信道,允许冲突,全速率传输 从冲突中恢复 时隙ALOHA(slotted ALOHA)-极限37%效率假设 所有帧长度相同 时间划分为等长间隙,能传输一个帧 结点仅在时隙开始时开始传输帧 如果2+结点同时传输,所有结点检测到冲突 工作原理 有新帧,在下一个时隙传输 无冲突,直接发送 有冲突,在之后的每个后继时隙中以概率p重新传送 纯ALOHA(pure ALOHA)-极限18%效率削弱版时隙ALOHA 帧到达立马传输,有冲突则等待一段随机时间开始传输 CSMA 载波侦听多路访问思想 在传输前侦听 信道空闲: 传输整个帧 信道忙;推迟传输(下列三种推迟策略) 等待信道空闲(1-坚持) 等待随机时间(非坚持) 等待空闲,然后概率p发送(p-坚持) 传播时延的冲突 信道非真正空闲 争用期/冲突窗口:端到端往返时延 2$\\tau$ 只有争用期没检测到冲突才能肯定此次发送不会产生冲突 每个发送数据帧的结点,需要经过争用期才能确保这次发送不会产生冲突 CSMA/CD 载波侦听多路访问+冲突检测CD:Collision Detection 使用CSMA协议进行数据发送 发送过程中一直侦听信道&lt;u&gt;(冲突检测)&lt;/u&gt; 检测到冲突则立即停止发送,并等待一段随机时间,再侦听 为了在发送时能检测到可能存在的冲突,CSMA.CD要求所有数据帧都必须大于最小帧长(2$\\tau$*数据传输速率) CSMA/CAIEEE802 无线局域网所用的多路访问协议,参考后续 5.3.3轮流访问[不考]节点轮流发送，但有更多信息要发送的节点能够占用更 长的时间 5.4局域网(LAN)5.4.1局域网的基本概念与体系结构集中在一个地理区域中的计算机网络 属性 范围限制 传输技术 拓扑结构 IEEE802参考模型-只相当于链路层和物理层 LLC保证传输正确性 MAC解决共享信道访问 5.4.2链路层寻址与ARP协议MAC地址/LAN地址/物理地址 将数据报从一个接口传送到物理上相互连接的另一个接口 网络层及以上用IP地址,链路层及以下用硬件地址 ARP:地址解析协议每个主机上设有ARP高速缓存,里面有所在局域网上各主机和路由器的IP地址到硬件地址的&lt;u&gt;映射表&lt;/u&gt; A想向B发数据,先查看ARP中有无B的IP,如果有,就查出它的硬件地址,再将其发送 没有,则运行ARP来找到B的硬件地址 即主机A向所有主机广播请求,目的主机对主机A直接回应,同时将主机A的地址映射到自己的高速缓存中 ARP四种情况 主机-&gt;本网络上另一个主机 ARP找到目的硬件地址 主机-&gt;另一个网络上的主机 ARP找到本网络一个路由器地址 路由器-&gt;本网络主机 ARP找到目的主机的硬件地址 路由器-&gt; 另一个网络主机 ARP找到本网络上另一个路由器硬件地址 5.4.3以太网与IEEE802.3星型拓扑结构 中心是交换机 节点间不冲突 以太网帧结构 目的地址: 第一位0: 单节点接收 1:被一组节点接收 全1:广播 校验字段 32位CRC校验(范围:目的地址,源地址,类型,数据) 数据字段:最小长度为46B,小于46则填充,但这些填充不计入长度字段值中最大长度为1500B 因此Ethernet帧最小长度64B,最大1518B 以太网特点不可信(接收方不发送ACK之类的) 无连接(无握手) MAC控制: 以太网的CSMA/CD将之前的强化冲突方式,设置为使用&lt;u&gt;二进制指数退避&lt;/u&gt; 在第m号冲突后 NIC选择{0,1,2,…$2^{m-1}$中的随机一个数K 然后等待K*512 bit时间 5.4.4无线局域网与IEEE802.11[不考]无线网的介质访问控制 特点: 无法获得冲突信息 目的:避免冲突 方式 物理层执行信道载波侦听 信道空闲–源节点等待DIFS后,仍然空闲,则发送一帧,然后等待ACK帧 目的节点在收到正确的数据帧的SIFS时间后,向源节点发送ACK帧 CSMA/CA允许发送端预订信道 发送端发送请求帧到AP AP广播允许发送(CTS)的回复 所有结点收到CTS,发送端发送 5.5数据链路层设备局域网交换机存储并转发以太网帧 特征: 对主机透明(即ip地址什么的和它无关) 自学习- 收到对应接口分组后记录对应接口MAC地址在自己对应接口上 如果发现目的接口没有,会洪泛(将分组分发到所有接口上,等待回复) 冲突域VS广播域冲突域;网络的一部分,在其中会发生帧冲突(当两个设备同时发送数据报) 广播域:包含了通过链路层广播能直接相互了解的所有设备 虚拟局域网–为了防止过多的广播信息引起不便虚拟局域网VLAN是由一些局域网网段构成的与物理位置无关的逻辑组 每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的工作站是属于哪一个 VLAN。(在以太网帧中插入一个4字节的标识符,称为VLAN标记) 6. 物理层6.1通信基础6.1.1数据通信系统的基本概念物理层目标:在通信信道上传输原始比特 确定与传输介质的接口的一些特性 机械特性 电气特性 功能特性 过程特性 6.1.2编码与调制6.1.3奈奎斯特定理和香农定理6.2物理层设备集线器7. 综合7.1各层设备的广播域、冲突域及总结7.2Web访问全过程","link":"/2021/12/11/2021-12-11-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/"},{"title":"MC服务器设置","text":"MC服务器设置[toc] 今天心血来潮搞了个mc服务器,下面记录一下过程 基础配置服务器系统:Debian(我也不知道是什么版本,反正是vultur上买的) java版本:openjdk8 具体下载过程在后面有说 之后参考教程教程/架设服务器 - Minecraft Wiki，最详细的我的世界百科 (fandom.com) java下载参考: 如何在Debian 10 Linux上安装Java (myfreax.com) 执行以下代码即可 12345678910sudo apt updatesudo apt install apt-transport-https ca-certificates wget dirmngr gnupg software-properties-comwget -qO - https://adoptopenjdk.jfrog.io/adoptopenjdk/api/gpg/key/public | sudo apt-key add -sudo add-apt-repository --yes https://adoptopenjdk.jfrog.io/adoptopenjdk/deb/sudo apt updatesudo apt install adoptopenjdk-8-hotspot 最后看看是否真的安装了 1java -version 预计输出如下 123openjdk version &quot;1.8.0_212&quot;OpenJDK Runtime Environment (AdoptOpenJDK)(build 1.8.0_212-b04)OpenJDK 64-Bit Server VM (AdoptOpenJDK)(build 25.212-b04, mixed mode) 服务器配置基础代码仓我直接用了已有的github仓库(不想自己搞了) 直接在Linux命令行下输入这些就行 1234567wget https://github.com/silvertriclops/MCSLI/archive/master.zipunzip master.zipcd MCSLI-master sudo chmod +x install.shsudo chmod +x start.sh./install.sh # tells the computer where Java is so it knows how to start Minecraft./start.sh # starts the Minecraft server. You may want to run this command inside screen. 理论上来说,这样就已经可以用了 输入 stop退出 开放tcp端口因为是服务器,需要和客户端交互,一个tcp端口是必不可少的 一般来说,根据上面创建的服务器,默认使用的是25565(启动的时候中间有一行会提示的) 就像下面这样 然后输入下面代码就能开放对应端口(不过我也不知道开了到底会有什么坏影响,服务器做好备份?) 12sudo iptables -A INPUT -p tcp --dport 25565 --jump ACCEPTiptables-save 换成我想要的版本(1.12)不过这个仓库七年前就停止更新了,里面的服务器版本为1.8版本 想更新成自己的版本需要去MC官网下,就几十mb很小,下载好对应版本后 回到之前的文件夹(MCSLI-master) 把对应版本的文件放进来 如果不知道怎么把文件传给服务器,看下面 我用的Xshell连接服务器,这时候可以下载xftp,用于文件传输,图形化界面,用了都说好 之后更改配置(MCSLI-master/start.sh) 里面能看到写了一行启动代码,把它里面对应服务器jar包的那部分换成你的jar包(相对位置绝对位置都可以) 看看能不能用 1./start.sh 只要不报错就算成功 加装modmod是mc的灵魂,不打mod我不认可(实际就是我菜) 这时候需要下载forge 打开forge的官网 Downloads for Minecraft Forge for Minecraft 1.12 下载对应的版本,我是1.12就下载了1.12 放到和刚才文件同一级目录下 执行 1java -jar forge-1.12-14.21.1.2443-installer.jar --install 这时候你使用 ls 看看文件夹下,可以看到有类似 这种东西出现 那么你的forge安装已经成功了一半了 之后打开你该死的本地MC(加装了对应版本forge的那种) 把.minecraft下的resources文件夹,整个给复制到服务器里头去(还是刚才那个文件目录) 之后执行 1./start.sh 最后能看到这些信息就算成功 享受服务器打开你的本地MC,输入服务器ip,连接后进入就行 啸贴士如果你一不小心做错了,或许可以评论,我期末摸鱼的时候可能会来评论一下","link":"/2021/12/19/2021-12-19-MC%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE/"},{"title":"白盒测试","text":"白盒测试定义知道内部工作过程，可通过测试内部动作来测试 目标通过测试来检测软件产品内部动作是否按照规格说明书的规定正常执行 重点看软件内部各条通路是否按照规定工作 特点黑盒可能存在负负得正的情况，而白盒不会 白盒能发现一些隐患：如内存泄漏，误差累积等 作用主要想对程序模块进行如下的检查 对所有独立测试路径至少测试一次 对所有的逻辑判定，取真/假的两种至少测试一次 在循环的边界和运行界限内执行循环体 测试内部数据结构的有效性 局限一个具有多重选择和循环嵌套的程序，不同的路径数目可能是天文数字。 比较 如何安排白盒测试单元测试集成测试 集成阶段，依据概要设计说明书 静态结构分析 代码质量度量 功能确认与接口分析 覆盖率分析 性能分析 内存分析 系统测试到这步已经很少做白盒测试了 验收测试白盒测试综合策略 在测试中，应尽量先用工具进行静态结构分析。 测试中可采取先静态后动态的组合方式：先进行静态结构分析、代码检查和静态质量度量，再进行覆盖率测试。 利用静态分析的结果作为引导，通过代码检查和动态测试的方式对静态结构分析结果进行进一步的确认，使测试工作更为有效 覆盖率测试是白盒测试的重点，一般可使用基本路径测试 法达到语句覆盖标准；对于软件的重点模块，应使用多种覆盖标准衡量代码的覆盖率。 在不同的测试阶段，测试的侧重点不同：在单元测试阶段 ，以代码检查、逻辑覆盖为主；在集成测试阶段，需要增加静态结构分析、静态质量度量；在系统测试阶段，应根据黑盒测试的结果，采取相应的白盒测试 白盒测试用例设计技术静态 代码检查（人工＋工具） 静态结构分析（主要由软件工具自动进行） 软件质量度量（主要由软件工具自动进行 动态","link":"/2022/03/09/2022-03-09-%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/"},{"title":"黑盒测试","text":"测试用例选择 为每一个等价类规定一个唯一编号； 设计一个新的测试用例，使其尽可能多地覆盖 尚未被覆盖的有效等价类，重复这一步，直到 所有的有效等价类都被覆盖为止； 设计一个新的测试用例，使其仅覆盖一个尚未 被覆盖的无效等价类，重复这一步，直到所有 的无效等价类都被覆盖为止 分类是否是三角形的三条边等价类A&gt;0 B&gt;0 c&gt;0 A+B&gt;C B+C&gt;A A+C&gt;B 非等价类A&lt;=0 B&lt;=0 C&lt;=0 A+B&lt;=C … 是否等腰等价类A=B B=C C=A 非等价类A!=B！=C 是否等边等价类A=B=C 非等价类A!=B B!=C C!=A 边界值分析法（单缺陷假设）比最大值稍微小一点，比最小值稍微大一点 健壮性测试：（再多两个点） 比最大值稍微大一点，比最小值稍微小一点 最坏情况测试： 多变量取极值的情况 健壮最坏情况测试 最坏情况取超边界情况 错误推测法根据经验推测 简单有效，但系统性差，是其他的补充 判定表法 判定表是一种用来表示和分析复杂逻辑关系的工具，最适 合描述在多个逻辑条件取值的组合所构成的复杂情况下， 分别要执行哪些不同的动作。 条件桩（Condition Stub）：列出了问题的所有条件。通常认为列出的条件的次序无关紧要。 动作桩（Action Stub）：列出了问题规定可能采取的操作。这些操作的排列顺序没有约束。 条件项（Condition Entry）：列出针对它所列条件的取值，在所有可能情况下的真假值。 动作项（Action Entry）：列出在条件项的各种取值情况下应该采取的动作 例子 “……对于功率大于50马力的机器，并且维修记录不全或已运行 10年以上的机器，应给予优先的维修处理…… （1）列出所有的条件桩和动作桩 – 条件桩 C1：功率大于50马力吗？ C2：维修记录不全吗？ C3：运行超过10年吗？ – 动作桩 A1：进行优先处理 A2：做其他处理 （2）确定规则个数 – 输入条件个数：3 – 每个条件的取值：“是”或“否” – 规则个数：222 =8 因果图法 从用自然语言书写的程序规格说明 的描述中找出因（输入条件）和果（输出或程序状态的改 变），通过因果图转换为判定表 基本步骤 分析软件规格说明描述中，哪些是原因（即输入条件或输入 条件的等价类），哪些是结果（即输出条件），并给每个原因和 结果赋予一个标识符。 分析软件规格说明描述中的语义，找出原因与结果之间，原 因与原因之间对应的关系，根据这些关系，画出因果图 由于语法或环境限制，有些原因与原因之间，结果与结果之 间的组合情况不可能出现。为表明这些特殊情况，在因果图上用 一些记号标明约束或限制条件 把因果图转换成判定表。 把判定表的每一列拿出来作为依据，设计测试用例 图形符号","link":"/2022/03/11/2022-03-11-%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/"},{"title":"React学习20220312 生命周期","text":"React学习20220312CreateElement函数拆解 生命周期 React16 挂载过程 getDerivedFromProps的功能：使用props来派生/更新state 是针对某个属性的定向更新 更新过程 getSnapshotBeforeUpdate: React16引入的Fiber架构 之前组件更新：树状递归更新，同步更新，占用主线程，易卡死 Fiber会把大任务转为小任务，使得渲染线程可打断 重要特征 可以被打断的异步渲染模式 react将渲染过程分为render和commit两个过程 render可被打断 commit同步执行 因为commit会改视图，因此不可打断 数据的流动基于props的单向数据流： 当前组件的state以props的形式流动时，只能流向组件树中比自己层级更低的组件 父子组件通信 父组件把this.props传入子组件 子父组件通信 父组件向子组件传递一个绑定了自身上下文的函数 子组件在调用该函数时， 就可以把想要交给父组件的数据以函数入参的形式传入","link":"/2022/03/12/2022-03-12-React%E5%AD%A6%E4%B9%A020220312/"},{"title":"React学习20220313 Hook","text":"React学习20220313 Hook理解Hook按我的理解，Hook是对繁琐，学习曲线长，难以更改中间步骤的类的拆分，使得函数可以拥有一些类能够使用的功能：如state和生命周期等，而且Hook所辅助的函数式编程比较符合React所推崇的组件化编程。 对useState的理解充当函数中的state，但一次只有一个，不像类中一次指定多个 [text,setText] =useState(‘初始文字’) useState返回一个数组，数组第一个是想要的state变量，第二个是修改变量的Api 对useEffect的理解弥补生命周期 接收两个参数：回调函数和依赖数组 useEffect(callBack,[]) 调用规则： 每次渲染后：传入回调函数，不传依赖数组： useEffect(callBack) 挂载阶段执行一次后不再执行：传入回调函数，且此函数的返回值不是函数，同时传入空数组。 useEffect(()=&gt;{/*业务逻辑*/},[]) 仅在挂载和卸载阶段执行的：传入回调函数，且此函数的返回值是一个函数 123456useEffect(()=&gt;{//业务逻辑//返回一个函数记为Breturn ()=&gt;{}},[]) 每次渲染都触发，且卸载阶段也会被触发的：传入回调函数，且这个函数的返回值是一个函数，同时不传第二个参数 12345678useEffect(()=&gt;{ //A的业务逻辑 //返回一个函数记为B return ()=&gt;{ }}) 上面这段代码在每次渲染都触发A逻辑，并在卸载阶段触发B逻辑 按我的理解，在前面一半写个函数会在渲染阶段一直触发，单纯写一段逻辑就会在挂载阶段触发，在return那写个函数就会在卸载的时候触发 不要在循环，条件或嵌套函数中调用Hook首次渲染过程 hook相关的所有信息收敛在一个hook对象粒，而hook对象之间以单向链表的形式相互串联， 更新过程 因此，hooks的渲染是通过“依次遍历”（也就是说，它只会管这回需要前进几个next，而不会对对应位置的真实性进行判断）来定位每个hooks的内容的，如果前后两次读到的链表顺序出现差异，那么渲染的结果自然是不可控的。","link":"/2022/03/13/2022-03-13-React%E5%AD%A6%E4%B9%A020220313%20Hook/"},{"title":"React学习20220314 虚拟DOM","text":"React学习20220314 虚拟DOM虚拟DOM是什么是JS和DOM之间的一个映射缓存，在形态上表现为一个能够描述DOM结构及其属性信息的JS对象。 在REACT中，表现为 是JS对象，是对真实DOM的描述 如何工作 挂载阶段：结合JSX的描述，构建出虚拟DOM树，然后通过ReactDOM.render实现虚拟DOM到真实DOM的映射 更新阶段，页面的变化在作用于真实DOM之前，先作用于虚拟DOM，虚拟DOM在JS层借助算法先对比出那些真实DOM需要被改变，然后将改变作用于真实DOM 这一段历史讲得好有趣，摘下来 可以看出，模板语法其实就是把 JS 和 HTML 结合在一起的一种规则，而模板引擎做的事情也非常容易理解。 把 staff 这个数据源读进去，塞到预置好的 HTML 模板里，然后把两者融合在一起，吐出一段目标字符串给你。这段字符串的内容，其实就是一份标准的、可用于渲染的 HTML 代码，它将对应一个 DOM 元素。最后，将这个 DOM 元素挂载到页面中去，整个模板的渲染流程也就走完了。 这个过程可以用伪代码来表示，如下所示： // 数据和模板融合出 HTML 代码 var targetDOM = template({data: students}) // 添加到页面中去 document.body.appendChild(targetDOM) 当然，实际的过程会比我们描述的要复杂一些。这里我补充一下模板引擎的实现思路，供感兴趣的同学参考。模板引擎一般需要做下面几件事情： 读取 HTML 模板并解析它，分离出其中的 JS 信息； 将解析出的内容拼接成字符串，动态生成 JS 代码； 运行动态生成的 JS 代码，吐出“目标 HTML”； 将“目标 HTML”赋值给 innerHTML，触发渲染流水线，完成真实 DOM 的渲染。 使用模板引擎方案来渲染数据是非常爽的：每次数据发生变化时，我们都不用关心到底是哪里的数据变了，也不用手动去点对点完成 DOM 的修改。只需要关注的仅仅是数据和数据变化本身，DOM 层面的改变模板引擎会帮我们做掉。 如此看来，模板引擎像极了一个只需要接收命令，就能够把活干得漂漂亮亮的“扫地机器人”！可惜的是，模板引擎出现的契机虽然是为了使用户界面与业务数据相分离，但实际的应用场景基本局限在“实现高效的字符串拼接”这一个点上，因此不能指望它去做太复杂的事情。尤其令人无法接受的是，它在性能上的表现并不尽如人意：由于不够“智能”，它更新 DOM 的方式是将已经渲染出 DOM 整体注销后再整体重渲染，并且不存在更新缓冲这一说。在 DOM 操作频繁的场景下，模板引擎可能会直接导致页面卡死。 注：请注意小标题中“早期”这个限定词——本课时所讨论的“模板引擎”概念，指的是虚拟 DOM 思想推而广之以前，相对原始的一类模板引擎，这类模板引擎曾经主导了一个时代。但时下来看，越来越多的模板引擎正在引入虚拟 DOM，模板引擎最终也将走向现代化。 虽然指望模板引擎实现生产力解放有些天方夜谭，但模板引擎在思想上无疑具备高度的先进性：允许程序员只关心数据而不必关心 DOM 细节的这一操作，和 React 的“数据驱动视图”思想如出一辙，实在是高！ 那该怎么办呢？ jQuery 救不了加班写 DOM 操作的前端，模板引擎也救不了，那该怎么办呢？ 这时候有一批仁人志士，兴许是从模板引擎的设计思想上得到了启发，他们明确了要走“数据驱动视图”这条基本道路，于是便沿着这个思路往下摸索：模板引擎的数据驱动视图方案，核心问题在于对真实 DOM 的修改过于“大刀阔斧”，导致了 DOM 操作的范围过大、频率过高，进而可能会导致糟糕的性能。然后这帮人就想啊：既然操作真实 DOM 对性能损耗这么大，那我操作假的 DOM 不就行了？ 沿着这个思路再往下走，就有了我们都爱的虚拟 DOM。 注：出于严谨，还是要解释下。真实历史中的虚拟 DOM 创作过程，到底有没有向模板引擎去学习，这个暂时无从考证。但是按照前端发展的过程来看，模板引擎和虚拟 DOM 确实在思想上存在递进关系，很多场景下，面试官也可能会问及两者的关系。因此在此处，我采取了这样一种表述方式，希望能够帮助你更好地把握住问题的关键所在。 虚拟DOM使得之前的全局刷新，改成了有更新的部分更新，在真实DOM前加了一层 虚拟DOM解决的问题重心不是性能 Reconciliation过程与Diff算法Diff算法找两个树结构之间的不同 两个规律 对于Key，下图可以比较好地展示使用了Key后的更新策略 如果不使用key，则仅有AB可保留，其他均被重建","link":"/2022/03/16/2022-03-14-React%E5%AD%A6%E4%B9%A020220314%20%E8%99%9A%E6%8B%9FDOM/"},{"title":"React学习20220314 SetState","text":"React学习20220314 SetState初始认知setState之后立马访问对应state，会发现它并没有改变，而是会在之后某个时间发生变化 异步的动机和原理 异步避免重复reRender 从源码角度看异步setState 再查看batchingStrategy 理解Transaction（事务）机制 同步现象的本质","link":"/2022/03/16/2022-03-14-React%E5%AD%A6%E4%B9%A020220314%20SetState/"},{"title":"字节二面记录","text":"2022/4/2 字节二面记录 啸问题:开头以为只有暑假可以实习,直接被面试官拒了,然后被同学提醒才发现开学也能实习,紧急联系回来了 面试官还挺好的,居然还能继续面 问了些啥最开始还是最难顶的自我介绍,感觉像是一个垃圾桶被要求介绍自己(x),我下次应该记住重复一下北理是个985,不然听起来像个野鸡大学( 和一面不同的是,这回自我介绍完了就开始做题,还问了python里头元组和字典的关系(答不出来,寄) 计网方面问了http请求一个页面的过程(上学期刚上完这学期就忘得差不多了属于是) 这回没问数据库,不知道是为啥 问了对软件项目管理的理解(?),我就当问我管理上的看法,感觉有点答非所问 哪里不行对语言的理解比较烂,属于是只知道用不知道学 计网还是得看看http请求的全过程 其实数据库查询语句还有点欠缺,不过能用","link":"/2022/04/02/2022-04-02-%E5%AD%97%E8%8A%82%E4%BA%8C%E9%9D%A2%E8%AE%B0%E5%BD%95/"},{"title":"微型数据库开发记录","text":"前言近三周应小学期老师要求，和4位队友合作开发了一个微型数据库系统。由于耗费了许多的精力，我想将开发过程记录在这个博客上。 功能性需求： 创建数据库和表，能够以文件形式保存在磁盘上（操作系统的文 件、进程管理，数据结构 的 B树） 支持表的增删改查（数据库 中SQL形式，编译的词法语法检查） SQL中支持通配符（数据结构的查找）、多表连接（操作系统 的 文件管理） 支持整数、实数、字符（串）、日期等数据类型 支持索引（数据库、数据结构 ） 性能性需求 单表记录最大行数不少于10万行，不少于10 列 单表响应时间不多于 1秒（普通笔记本） 主表不少于5000行，子表不少于20000行时，连接操作响应时 间不多于 2 秒 痛苦的开端最初的迷茫开始的时候确实是啥也不知道，一堆人在教室里商量了半天也没想明白该干些什么，就留了两天各自查资料。等大家查完，在教室里一讨论，就发现任务极其重大。由于要实现5000*20000级别的表连接，还有100 000级别的数据插入，因此我们需要考虑底层的文件存储，但由于开发经验的不足和工期较短，我们在讨论中断定，凭空实现完全的页面管理对我们来说是不可能的，因此决定退而求其次，找一份有页面管理的借鉴一下。 因此，我们翻看了sqlite的源码，还通篇学习了一门斯坦福的课程（代码仓库叫redbase）,在途中，还重新确定了我们要实现的关键字等需求。 借鉴都借鉴不明白然后就出现了问题，我们找到了一份很好的页面管理代码，但光页面管理（包括缓冲区管理）的代码量就直接超过了8000行，为了实现它我们需要做的工作过于繁复（虽然我们确实尝试了一天）。 同时，Linux开发也对我们组造成了较大的麻烦，因为有开发经验的仅有一人，其他人光环境配置就花了很长时间。后来采用先富带后富的方式，总算是搞定了整组的环境。 借鉴不了，想一个自己的框架吧！最后，我们发现，我们的这种特种需求，只有我们自己琢磨一个框架来才能够满足3周内开发完成，且能够实现一定的文件管理和查询优化。 这里用文字形容一下我们初步商量的框架 顶层：词法分析-&gt;语法分析，产出一棵抽象语法树 中层：语义分析，并实现一系列数据库操作函数 底层：B+树代码和物理存储管理代码，存储二进制数据。 中层咱暂时实在想不明白，就先大致写了一点儿，之后先把顶层和底层开发出来，到时候再看中层该怎么搞。 辛苦又充满成长的开发过程经历了鸡飞狗跳，还有一堆学校其他杂事（搬家，做华为云实验）的一周之后，我们正式开始开发。 顶层顶层被我们归类为最困难的工作，我们想了些取巧的办法让它稍微简单一点儿。这块儿是组里大佬写的，我也只是有所了解。 参考redbase的顶层（就算是斯坦福的课，顶层代码也是预先写好，不用学生写的），我们按照自己的需求写了一份语法文件，并用yacc（应该）生成分析代码。 底层第二周折腾了老半天，把一份B+树代码折腾出来了，它还满足我们的要求（改泛型改了一个周末）：能够存储int，float和string类型的数据（本来还有个要求是，一级索引将和纯数据文件放在一起，方便存取，但泛型这东西实在不是一个初学c++的同志能整的这么明白的，就没实现） 数据文件（初版）这里给出示例文件框架 save -table1 示例表名 –table1.data存放二进制数据文件 —-table1.meta存放表说明文件 —-IND//存放索引 ——-table1//自增主键索引 —其他索引","link":"/2022/09/04/2022-09-04-%E5%BE%AE%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"},{"title":"计组复习","text":"指令系统基本格式： 操作码| 地址码 （字节的整数倍） 地址码结构 四地址指令： A1 OP A2 -&gt; A3 4次访存 三地址： 四地址-A3 （通过PC+1获得下一条指令位置） 4次访存 二地址： 三地址-A3 （ 结果存放在A1位置）4次访存 一地址： A_cc OP A1-&gt;Acc (Acc在累加寄存器中) 2次访存 零地址： 都在堆栈中 操作码定长： 简化架构，但利用率低 变长：设计复杂，但同字节长度下可支持较多指令 编址方式目的： 指出操作数的来源和去向 需要编址的：通用寄存器，主存，输入输出设备 编址单位 字编址编址单位=访问单位，每个编址单位所包含的信息量与读写寄存器所得的信息量相同 字节编址编址单位&lt;访问单位编址单位和信息的基本单位（一个字节）相一致 位编址先不谈 地址码的位数与主存容量成正比，和最小寻址单位成反比 数据寻址目的：找到所需的操作数 立即寻址直接取出操作数 寄存器寻址给出寄存器编号，再访问寄存器取出操作数 直接寻址取出操作数再主存中的地址 间接寻址从主存中取出存放操作数地址的地址 寄存器间接寻址获取寄存器编号，寄存器中该编号存放操作数在主存的地址 变址寻址读取形式地址A加上变址寄存器Rx的值，获取真实地址 基址寻址读取位移量D，与基址寄存器中的值相加获得真是地址 相对寻址相对于基址寻址，由程序寄存器提供基准地址 页面寻址将整个主存空间分成若干个大小相同的页，每页有自己的编号，称为页面地址，业内的主存单元也有自己的编号，称为页内地址，操作数的有效地址就被分为：页面地址和页内地址两部分有三种页面寻址方式 基页寻址有效地址为 0//A （//为简单拼接) 当前页寻址页面地址为程序计数器PC的高位部分，有效地址为(PC)h // A 页寄存器寻址页面地址取自页寄存器，与形式地址拼接形成操作数有效地址EA=(页寄存器)//A 指令寻址目的：寻找下一条要执行的指令地址 顺序寻址：PC+1(程序计数器加1) 跳跃寻址：通过程序转移类指令实现 直接、相对、间接寻址（详见数据寻址） 堆栈与堆栈操作堆栈结构 寄存器堆栈一组专门的寄存器构成，栈顶固定，且组中寄存器互相连接，可将一个寄存器中的内容推移到另一个寄存器中去 存储器堆栈从主存中划出一块区域来当堆栈，大小可变，栈底固定，栈顶浮动，需要一个硬件寄存器作为堆栈栈顶指针SPPS: 栈底指针地址大于栈顶地址，因此进栈时，栈顶指针先减一，然后将数据压入指针指向的堆栈位置 堆栈操作（用途）【一般计算机】 暂存中断断点 子程序调用时的返回地址 状态标志 现场信息 子程序调用时参数的传递 因此访问堆栈的指令只有进栈和出栈两种。 指令类型数据传送类指令用于寄存器与寄存器，寄存器与主存 ，主存与主存之间的数据传送 一般传送指令：将源地址的数据复制到目的地址 堆栈操作指令：因为堆栈（主存中开辟的）是一个特殊区域，因此对堆栈的操作也就是对存储器的操作 数据交换指令：将源操作数和目的地操作数相互交换位置 运算类指令 算术运算指令 逻辑运算指令 移位指令（算数移位【保持操作数符号不变，左移数值*2，右移数值/2】，逻辑移位【不管符号】，循环移位） 程序控制类指令用于控制程序的执行方向，并使程序具有测试、分析与判断的能力 转移指令无条件（JMP）： 直接吧程序转向新的位置执行条件转移：条件满足才转移 子程序调用指令子程序是一组可以公用的指令序列，只要知道地址就能调用主程序转向子程序称为子程序调用指令（CALL）子程序转向主程序成为转移指令（RET）一般使用堆栈保持返回地址 返回指令（RET） 输入输出类指令实现主机与外部设备之间的信息交换 独立编址的IO独立编址：外设端口和主存单元独立编址，指令系统有专门的IN/OUT指令，信息从外设到主机称为输入 指令中给出外设端口地址，这些地址是另一个独立的地址空间 统一编址的IO指令系统没有专门的IO指令，用一般的数据传送类指令来实现 数值的机器运算基本算数运算的实现并行可以加快过程，但并行会使计算式过长，因此采用并串联合使用的方式取得性能和逻辑的平衡 单级先行进位方式组内并行，组间串行 多级先行进位方式组内并行，组间也并行 定点加减运算补码加法：[X+Y]补=[X]补+[Y]补 减法也只是加补码求反后的结果 后面的先不看了 存储系统和结构组成按作用分类 高速缓冲存储器 位于主存和CPU之间 主存储器 CPU 可直接访问 辅助存储器 CPU不能直接访问 存取方式分类 RAM 随机存取存取时间相同，随机读写访问 ROM 只读特殊的RAM，只能读不能写 SAM 顺序存取只能按某种顺序存取，存取时间与存储体上的物理位置有关 DAM 直接存取存储器读取步骤： 第一步直接指向存储器中的某个小区域，第二部在小区域内顺序检索 存取层次结构cache 主存 辅存 分为两个层次 Cache-主存 存储层次目的：解决主存速度不足 方式： 在CPU和主存之间，增加辅助硬件，让他们构成一个整体，使CPU速度接近cache，容量接近主存 主存 - 辅存存储层次目的：解决主存容量不足 主存储器的组织基本结构存储体 地址译码驱动电路 译码器和驱动器，译码器将地址总线输入的地址吗转换成输出线上的有效电平，驱动器提供驱动电流去驱动相应的读写电路 IO和读写电路 存储单元位： 二进制数的最基本单位，也是存储器存储信息的最小单位 存储字：一个二进制数由若干位组成，当这个二进制数作为一个整体存入或取出时，这个数称为存储字 存储单元（主存单元) 存放存储字或存储字节的主存空间，由计算机的结构确定。是CPU对主存可访问擦欧总的最小存储单位。 存储体： 大量存储单元集合构成一个存储体 技术指标 存储容量指主存所能容纳的二进制信息总量，对字节编址的计算机，以字节数表示，对字编址的计算机，以字数和字长的乘积来表示 存取速度2.1 存取时间从启动一次存储器操作到完成该操作所经历的时间2.2 存取周期指存储器进行一次完整的读写操作所需的全部时间，连续两次访问存储器操作之间所需要的最短时间 主存带宽每秒从主存进出信息的最大数量（字/秒或 字节/ 秒 或 位/ 秒） 半导体随机存储器和只读存储器动态RAM的刷新刷新方式集中式集中安排若干个刷新周期，刷新时停止读写操作 时间=存储体矩阵行数*刷新周期 分散式把刷新操作分散到每个存取周期内进行，此时存取周期被分成读写和刷新两个部分。 异步式把刷新操作平均分配到整个最大刷新间隔时间内进行 刷新间隔=最大刷新间隔时间/ 行数 主存容量的扩展","link":"/2022/09/11/2022-09-11-%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/"},{"title":"21&#x2F;12&#x2F;6 Database exp 8","text":"分析系统功能 ER图 关系模型 对象的属性描述客户(&lt;u&gt;客户编号&lt;/u&gt;,电子邮箱,登录密码,身份证,联系方式,姓名)银行卡(&lt;u&gt;卡号&lt;/u&gt;,类型,客户编号)理财产品(&lt;u&gt;理财产品编号&lt;/u&gt;,理财年限,购买金额,产品名称,产品描述)基金(&lt;u&gt;基金编号&lt;/u&gt;,基金名称,基金类型,风险等级,基金管理者,基金金额)保险(&lt;u&gt;保险编号&lt;/u&gt;,保险名称,适用人群,保险项目,保险金额,保险年限)资产(&lt;u&gt;客户编号&lt;/u&gt;,&lt;u&gt;资产编号&lt;/u&gt;,状态,购买数量,收益,购买时间) 对象之间关系描述一个客户可以购买多种理财产品可以办理多张银行卡一个客户可以购买多种保险一个客户可以购买多种基金 物理设计与数据字典 表及其属性client(c_id,c_name,c_mail,c_id_card,c_phone,c_password)bank_card(b_id,b_type,b_c_id)property(p_id,p_c_id,p_i_id,p_status,p_amount,p_get_time,p_income,p_type)fund(f_name,f_id,f_type,f_amount,risk_level,f_manager)insurance(i_name,i_id,i_amount,i_person,i_year,i_project)f_product(fp_id,fp_name，fp_description，fp_amount，fp_year) 数据字典 表1-1 client表 字段名称 字段类型 约束 说明 c_id INTEGER PRIMARY KEY 客户编码 c_name VARCHAR(100) NOT NULL 客户名称 c_mail CHAR(30) UNIQUE 客户邮箱 c_id_card CHAR(20) UNIQUE NOT NULL 客户身份证 c_phone CHAR(20) UNIQUE NOT NULL 客户手机号 c_password CHAR(20) NOT NULL 客户登录密码 表1-2bank_card表 字段名称 字段类型 约束 说明 b_id INTEGER PRIMARY KEY 银行卡号 b_type CHAR(20) NOT NULL 银行卡类型 b_c_id INTERGER NOT NULLFOREIGNKEY 客户编号 表1-3 property资产表 字段名称 字段类型 约束 说明 p_id INTEGER PRIMARY KEY 资产编号 p_c_id INTEGER NOT NULLFOREIGN KEY 客户编号外键,对应client中的c_id p_i_id INTEGER NOT NULLFOREIGN KEY 商品编号 ,对应三种产品的id p_status CHAR(20) NOT NULL 状态 p_amount INTERGER NOT NULL 购买数量 p_get_time DATE NOT NULL 购买时间 p_income INTERGER 收益 p_type INTERGER NOT NULL 1代表是理财产品,2代表保险,3代表基金 表1-4 f_products 理财产品表 字段名称 字段类型 约束 说明 fp_id INTEGER PRIMARY KEY 理财产品编号 fp_year INTEGER 理财年限 fp_amount INTERGER 购买金额 fp_name VARCHAR(200) NOT NULL 产品名称 fp_description VARCHAR(2000) NOT NULL 产品描述 表1-5 insurance 保险表 字段名称 字段类型 约束 说明 i_id INTEGER PRIMARY KEY 保险编号 i_name VARCHAR(100) NOT NULL 保险名称 i_person CHAR(30) 适用人群 i_project VARCHAR(200) 保险项目 i_amount INTERGER 保险金额 i_year CHAR(20) NOT NULL 保险年限 表1-6 fund基金表 字段名称 字段类型 约束 说明 f_id INTEGER PRIMARY KEY 基金编号 f_name VARCHAR(100) NOT NULL 基金名称 f_type CHAR(30) 基金类型 f_risk INTERGER 风险等级 f_manager INTERGER NOT NULL 基金管理者 f_amount INTERGER NOT NULL 基金金额 创建数据库表 创建finance数据库作为项目数据库，数据库编码为UTF-8。（2分） 切换到omm用户 启动数据库服务 登入postres数据库(为了在里面创建新的数据库) 创建finance数据库,设置编码为UTF-8 连接finance数据库，创建名为finance的schema，并设置finance为当前的schema。（2分） 连接finance数据库 创建名为finance的schema，并设置finance为当前的schema 在finance模式下完成金融管理系统中所有数据库对象（数据表）的创建，并完成数据的填充。其中客户数据不少于20条，银行卡数据不少于10条，其他数据不少于5条；（6分） 数据表创建 客户表创建 银行卡表创建 理财产品表创建 保险信息表创建 基金信息表创建 资产信息表创建 添加数据 客户信息添加 银行卡数据填充 理财产品填充 INSERT INTO finance.f_products (fp_id ,fp_year ,fp_amount ,fp_name ,fp_description ) VALUES (1 ,2 ,4000000 ,’储蓄’ ,’储蓄理财产品’ ), (2 ,1 ,3000 ,’债券’ ,’债券是政府、企业、银行等债务人为筹集资金,按照法定程序发行并向债权人承诺于指定日期还本付息的有价证券’), (3 ,1 ,200000 ,’股票’ ,’股份公司为筹集资金而发行给各个股东作为持股凭证并借以取得股息和红利的一种有价证券’), (4 ,3 ,2000 ,’国债’ ,’国家以其信用为基础，按照债的一般原则，通过向社会筹集资金所形成的债权债务关系’), (5 ,2 ,10000 ,’大宗商品’ ,’与大宗商品期货挂钩的理财产品。目前市场上主要以挂钩黄金、石油、农产品的理财产品居多’) 保险产品填充 INSERT INTO finance.insurance(i_name,i_id,i_amount,i_person,i_year,i_project) VALUES (‘意外保险’,3,5000,’所有人’,20,’平安保险’), (‘医疗保险’,4,2000,’所有人’,20,’平安保险’), (‘健康保险’,1,2000,’老年人’,10,’平安保险’), (‘人寿保险’,2,3000,’老年人’,10,’平安保险’), (‘财产损失保险’,5,1500,’中年人’,3,’平安保险’); 基金表格填充 INSERT INTO finance.fund (f_id,fp_name,f_type,f_risk,f_manager,f_amount) VALUES (1,’股票基金’,’股票型’,3,1,200000), (2,’债券基金’,’债券型’,2,2,3000), (3,’投资基金’,’债券型’,3,2,1000), (4,’国债’,’货币型’,1,4,2000), (5,’期货’,’期货型’,2,5,1500); 资产表格填充 INSERT INTO finance.property (p_id , p_c_id ,p_i_id , p_status , p_amount ,p_get_time ,p_income ,p_type ) VALUES (1 ,1 ,1 ,’可用’ ,100 ,’2021-11-20’ ,2000 ,1 ), (2 ,1 ,2 ,’可用’ ,100 ,’2021-11-21’ ,3020 ,1 ), (3 ,1 ,1 ,’冻结’ ,100 ,’2021-11-20’ ,2000 ,2 ), (4 ,1 ,4 ,’可用’ ,101 ,’2021-11-10’ ,3000 ,3 ), (5 ,2 ,5 ,’可用’ ,100 ,’2021-11-20’ ,2000 ,2 ) 对表添加外键约束，在银行信息表和资产信息表中，都存在每个银行卡必须有一个持卡者、每份资产必须都有一个资产拥有者这样的对应关系。因此针对这种对应关系，创建外键约束。（4分） 添加外键约束 信用卡的外键ALTER TABLE finance.bank_card ADD CONSTRAINT fk_c_id FOREIGN KEY (b_c_id) REFERENCES finance.client(c_id) ON DELETE CASCADE; 资产的外键ALTER TABLE finance.property ADD CONSTRAINT fk_pro_c_id FOREIGN KEY (p_c_id) REFERENCES finance.client(c_id) ON DELETE CASCADE; 在理财产品表、保险信息表和基金信息表中，都存在金额这个属性，在现实生活中，金额不会存在负数。因此针对表中金额的属性，增加大于0的约束条件。（4分） 增加大于0的约束 f_products表ALTER table finance.f_products ADD CONSTRAINT c_p_mount CHECK (fp_amount &gt;=0); fund表 ALTER table finance.fund ADD CONSTRAINT c_f_mount CHECK (f_amount &gt;=0); insurance表ALTER table finance.insurance ADD CONSTRAINT c_i_mount CHECK (i_amount &gt;=0); 输出： 输出查询所有表的数据字典的查询语句和结果，可以截图或者复制黏贴代码。(基本都在之前有展示,这里对所有的表及schema进行了一次查询)select * from pg_tables; 输出查询所有表的数据的查询语句和结果，可以截图或者复制黏贴代码。 client表select * from finance.client; bank_card表select * from finance.bank_card; fund表select * from finance.fund; f_products表select * from finance.f_products; insurance表select * from finance.insurance; property表select * from finance.property; 输出所有创建约束的语句和创建结果，可以截图或者复制黏贴代码(这在之前已经放上了) 对表中的数据进行查询操作 l 至少完成1条单表查询和1条表查询。（4分）单表查询–查询客户表中所有的客户id select c_id from finance.client; 表查询select c_name from finance.client; l 至少完成两条聚合查询，例如查询用户表中有多少个用户；查询保险信息表中，保险金额的平均值等。（4分）查询property表的income平均值select avg(p_income) from finance.property查询用户表中用户总数select count(*) from finance.client; l 至少完成3条连接查询，例如：半连接、反连接、多表查询和子查询。（6分） 等值连接查询,查询每个用户及其拥有的资产select finance.client.*,finance.property. *from finance.client,finance.propertywhere finance.client.c_id=finance.property.p_c_id; 自身连接,在fund表中对每一个基金项,查询manager 和自身id相同的基金select first.*,second.f_managerfrom finance.fund first,finance.fund secondwhere first.f_id = second.f_manager 子查询,查询和p_id=3的资产处于相同状态的资产(然后发现就它自己冻结着)select * from finance.propertywhere p_status=(select p_status from finance.property where p_id=3); 至少完成1条ORDER BY查询。（2分）将资产按照收益逆序输出select * from finance.property order by p_income desc; 至少完成1条GROUP BY……HAVING查询。（4分） 查询收益在2000及以上的资产及其平均收益,将结果按p_id分组显示,且只显示平均收益大于2500的组select *,avg(p_income) from finance.propertywhere p_income&gt;=2000 group by p_idhaving avg(p_income)&gt;=2500; 查询基金,将其按f_id分组,且只显示平均数量大于等于2000的组select *,avg(f_amount) from finance.fundgroup by f_idhaving avg(f_amount)&gt;=2000; 4.5 创建视图和索引 创建一个视图 查看client中属性,除了c_mail属性create view see_clientasselect c_id,c_name,c_id_card,c_phone,c_passwordfrom finance.client 修改视图 修改视图所属schemaalter view see_client set schema finance; 使用视图进行查询 重命名视图alter view finance.see_clientrename to oh_my_god; 删除视图 创建索引为客户电话号码创建索引CREATE INDEX index_phone on finance.client(c_phone) ; 重建索引对整个客户表重建索引 重命名索引alter index finance.index_phone rename to ind_phone; 删除索引 1.4.6 数据修改和删除（5分）任务： l 修改数据：至少修改2个不同的数据。（3分） 将client表中第1个元素的值c_name改为’年没怀念’之前的表修改语句:update finance.clientset c_name=’年没怀念’where c_id=1; 修改后表情况 将property中p_get_time小于2021-11-11 00:00:00的值修改为2021-11-19 00:00:00 修改前状态修改update finance.propertyset p_get_time=’2021-11-19’where p_get_time&lt;’2021-11-11’;修改后状态 l 删除指定数据：至少删除2个不同数据表的数据。（2分） 将finance.property中p_amount=101的数据删除 删除前表情况 删除delete from finance.property where p_amount=101; 删除后表情况 删掉c_id&gt;20的用户信息 删除前表情况 删除操作 delete from finance.client where c_id&gt;20; 删除后表情况 1.4.7 创建新用户（6分）任务： 新用户的创建和授权：创建用户dbuser，密码为Gauss#3demo；给用户dbuser授予finance数据库下银行卡信息表的查询和插入权限，并将finance模式的权限也授予dbuser用户。（3分） 创建用户 给用户dbuser授予finance数据库下银行卡信息表的查询和插入权限，并将finance模式的权限也授予dbuser用户 新用户连接数据库：使用新用户连接finance数据库；访问finance数据库的银行卡信息表。（2分） 新用户连接 新用户访问finance数据库的银行卡信息表 删除finance模式。（1分） 1.4.8 使用jdbc连接openGauss数据库 创建测试数据库demo； 创建名为demo的schema，并设置demo为当前的schema设置搜索路径为demo SET search_path TO demo; 创建测试表websites（id,name,url），数据为（’1’, ‘openGauss’, ‘https://opengauss.org/zh/')，(‘2’, ‘华为云’, ‘https://www.huaweicloud.com/'), (‘3’, ‘openEuler’, ‘https://openeuler.org/zh/'), (‘4’, ‘华为support中心’, ‘https://support.huaweicloud.com/')。（3分）create table websites(id Integer primary key,name varchar(200),url varchar(200) );插入数据 INSERT INTO websites (id,name,url) VALUES (‘1’, ‘openGauss’, ‘https://opengauss.org/zh/'), (‘2’, ‘华为云’, ‘https://www.huaweicloud.com/'), (‘3’, ‘openEuler’, ‘https://openeuler.org/zh/'), (‘4’, ‘华为support中心’, ‘https://support.huaweicloud.com/') 查看入站规则是否包括tcp26000端口 查看java版本是否为8 创建项目,引入postgres.jar包 写下测试程序如下 结果 本实验完成","link":"/2021/12/06/21-12-6-Database-exp-8/"},{"title":"Bits Bytes and Integers","text":"Bits,Bytes and Integers基础位运算分清&amp;，&amp;&amp;，| ，||，~，!之间的区别位操作： &amp;，|，~，运算时只是单纯进行位操作 逻辑比较： &amp;&amp;，||，！，运算时会添加逻辑考虑， 比如||前面的为True，则提前中止调用 又比如，对一个非0的数进行！两次会获得一个1，这和位操作有很大的区别 算术右移和逻辑右移逻辑右移： 将整个数字向右移动，同时高位补0 算术右移： 将整个数字向右移动，同时高位按照符号位补充 左移的特殊情况如果一个八位的数字进行左移八位的操作，在部分计算机中，这个8将被模8，因此并不能得到想象中的0 补码 T国内讲法： 除了符号位，全部按位取反再加1 这课的讲法：最高位视为负权，如[-16,8,4,2,1] 经典图片 扩展例如：8位-&gt;16位 基本规则：将符号位复制k份，k为扩展位数 解释，想象负数的情况，假设最高位权重暂时是-8，增加一位最高位，新增一位-16，但之前的最高位变为+8，刚好抵消。 加减乘除无符号数直接不谈 补码加法： 可以通过补码加法简单得到减法，只要加上负的值就行 正/负溢出正溢出：俩正数加起来等于一个负数 乘法如果乘2的倍数，只需要【算术】移位就行了，不管是不是补码表示 除法同样是算术移位，但这回如果是负数，它就不是四舍五入，而是向负无穷舍入,例如 -3/2=-2。而不是-1 获得相反数按位取反再+1 一个恐怖的案例 这里，i会被隐式转换成unsigned int(因为sizeof是 unsigned int)，于是这个for循环不会结束 无符号数的优点由于无符号数的计算采用取模的方式 在一些模运算时（比如大多数加密算法） 当位表示集合而非数字时，用无符号数最好。 字存储最低有效字节在小端序电脑中放在首位，在大端机器中放在末位","link":"/2022/09/17/2022-09-17-csapp01/"},{"title":"floats","text":"浮点数基础知识浮点通过移动二进制小数点来表示尽可能大的取值范围数字公式$$(-1)^S M 2^E$$ 符号位{S} 表示正负 小数{M} 一般是一个1~2之间的小数值 指数位{E} 指的是乘2的E次方 IEEE浮点数标准single 单精度1位符号位，8位指数位，23位小数位 Double 双精度1位符号位，11位指数位，52位小数位 小数位的特殊表示由于小数位永远是1.010101这样的模式 因此前面的1不放入存储，只记录后面的01010101这种 同时，在计算时，会刻意维持小数位为1.010111这样的模式，就是说维持小数位在1~2之间 零表示法$$(-1)^S M 2^E$$ 此时E为1-Bias，之前为0-Bias 由于之前无法表示0，将M设置为0.110101010这种模式，此时可以表示0 当E全0，小数位全0的时候表示0 这会导致正负0的出现 当E为0，小数位不为0的时候，可以表示一些很接近0的东西 如果E为111111….1 ，frac 不为0，则代表一个极大值，不代表数字","link":"/2022/09/18/22-09-18-csapp02/"},{"title":"未继续_android与腾讯云mysql数据库连接_windows","text":"第一步 购买一个腾讯云服务 然后初始化(请记住密码) 开启外网地址(不然怎么连 第二步,下载androidstudio 第三步,下载对应数据库版本的jdbc,我的腾讯云是mysql8 jdbc位置是 MySQL :: MySQL Connectors 打开之后长这样,下载JDBC 这儿选platform independent,然后点第二个下载 解压之后能看到这个东西 把上面那玩意引入android 首先在project底下的app文件夹的子目录找到libs文件夹,把那个jdbc的jar包拖进去 如果没有,把左上角的这个调成ProjectFiles 看看,还没有就自己新建一个 右键它,选择add as library","link":"/2021/12/07/android%E4%B8%8E%E8%85%BE%E8%AE%AF%E4%BA%91mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5-windows/"},{"title":"CPU虚拟化","text":"MAIN TASK: 执行虚拟机程序指令，响应虚拟机内外部事件面临的挑战1. 敏感非特权指令挑战来源： 基于 陷入-模拟 机制的虚拟化架构只能在所有敏感指令都是特权指令的架构中被建立敏感指令： 操作敏感物理资源的指令，如I/O指令、页表基地址切换指令等特权指令； 必须运行在最高特权级的指令，在非特权级中执行这些指令将会触发特权级切换。解决方案： 软件方案： 解释执行【无脑解释执行所有指令，效率较低】，二进制翻译【将敏感指令替换为其他指令，会增加指令数量】，扫描与修补【在执行前，将敏感指令替换为特权指令，代码局部性较差】，半虚拟化【在执行敏感指令的时候通过超调用主动陷入Hypervisor中，避免扫描二进制代码引入的开销，但是打破了虚拟机和Hypervisor之间的界限】硬件辅助方案： Intel VT-x,AMD SVM, ARM EL2, RISC-V H-Extension将所有敏感指令转化为特权指令【可能存在兼容性问题】引入虚拟化模式 2. 上下文切换类似进程上下文，虚拟机发生退出时需要保持各寄存器的状态发生虚拟CPU调度时，需要保存当前虚拟CPU的上下文兵加载待调度虚拟CPU上下文 3. 中断处理模拟方式：为每一个虚拟机维护一个虚拟中断控制器 QEMU/KVM CPU虚拟化实现","link":"/2022/09/29/0929CPU%E8%99%9A%E6%8B%9F%E5%8C%96/"},{"title":"CSAPP 存储器层次结构 笔记","text":"6.1 存储技术 随机访问存储器 RAM 静态 SRAM 位存储模式:双稳态存储器单元 只要有电,就能永远保持值 动态 DRAM 位存储模式: 电容充电 比较 每位晶体管数 相对访问时间 持续? 敏感 相对花费 应用 SRAM 6 1 是 否 1000 高速缓冲存储器 DRAM 1 10 否 是 1 主存/帧缓冲区 非易失性存储器 ROM 关电后仍然能保持信息 访问主存 通过数据总线和主存信息交互 磁盘存储 从磁盘读数据的效率是从DRAM读数据的几乎10万倍慢,不过ssd会快的多,不过只是相对于传统磁盘而言 固态磁盘SSD 读SSD比写要快 因为随机写要擦除块,这个动作是毫秒级的 如果试图写一个有数据的块,会先将这块的数据复制到另一个没数据的地方 SSD多次重复写后会损坏 6.2局部性局部性原理计算机程序倾向于引用邻近与其他最近引用过的数据项的数据项 简单原则 重复引用相同变量的程序有良好的时间局部性 对于步长为k的引用模式的程序,步长越小,空间局部性越好. 对于取指令来说,循环有好的时间和空间局部性.循环体越小,迭代次数越多,局部性越好 6.3 存储器层次结构 L0 寄存器 –保存着从高速缓存中取出的字 L1 高速缓存 SRAM –缓存着从L2取出的缓存行 – 速度接近寄存器 L2 高速缓存 SRAM –缓存着从L3取出的缓存行 – 速度比L1慢 L3 高速缓存 SRAM –缓存着从主存高速缓存取出的缓存行 –速度比L2慢 L4 主存 DRAM – 保存着从本地磁盘取出的代码块 L5 本地耳机存储 本地磁盘 –保存着从远程网络服务器磁盘上读取的文件 L6 远程二级存储 [分布式文件系统,Web服务器] 6.4 高速缓存存储器6.4.1 通用的高速缓存存储器组织结构 存储器地址位数: m 存储器地址数: M=2^m 高速缓存组数 S= 2^s 高速缓存组内缓存行: E 缓存行内数据块 B=2^b 高速缓存大小: C=S*E*B 6.4.2 直接映射高速缓存 特征: 每个组只有一行,因此字选择时简单,但容易发生抖动 流程: 假设执行一条读内存字w的指令组选择: 从w中抽取s个组标记位,s由高速缓存组数决定 之后查看高速缓存中是否存在该组,如果存在就得到一个缓存命中,不存在就是缓存不命中 字选择: 高速缓存中的偏移位标识了字节在块中的偏移 行替换: 如果缓存不命中,就需要从层次结构的下一层中取出被请求的块,然后将心的块存储在组索引所示的块中 示例: 书P429 冲突不命中: 由直接映射的设计可以看出,如果程序访问大小为2的幂的数组,很可能会发生冲突不命中. 相同组映射的内存块会不断的来回覆盖–抖动 6.4.3 组相联高速缓存 每个组都有 1&lt;E&lt;C/B 个高速缓存行的 的高速缓存通常称为E路组相联高速缓存 如果E=C/B 称为全相联高速缓存 行匹配 检查多个行的标记和有效位,判断是否在缓存中 行替换 如果组中有空行,则换到空行上去 如果没有,则根据替换策略替换–比如LRU 6.4.4 写回 怎么更新层次结构中,低一层的副本 直写 – write throuth 立即将w的高速缓存块写回到紧接着的第一层 每次写都会引起总线流量 能够使用独立于高速缓存的写缓冲区用来更新内存 读不命中开销小 写回[ 延迟更新] write back 只有当替换算法要驱逐这个块时,将这个块写到低一层 显著减少总线流量 增加复杂性– 需要维护一个新的位[修改位] 允许更多到内存的贷款用于执行DMA的I/O. 如何处理写不命中就是说,要写的块拿不到 写分配 write-allocate 加载相应的低一层的块到高速缓存中,然后更新这个高速缓存块 写回高速缓存通常是写分配的 非写分配 not-write-allocate 避开高速缓存,直接把这个字写到低一层中 直写高速缓存通常是非写分配的 6.4.7 性能影响 不命中率 执行期间,内存引用不命中的比率 不命中数量/引用数量 命中时间 从高速缓存传送一个字到CPU所需的时间 不命中处罚 不命中所需的额外时间 下列因素提高的影响 高速缓存:命中率提高,命中时间提高 块大小:命中率提高,不命中处罚提高,损害时间局部性比空间局部性更好的程序的命中率 相联度:降低抖动可能,成本提高,增加不命中处罚 越往层次下面走,传送时间增加,减少传送的数量就更为重要.6.5 编写高速缓存友好的代码两个原则 让最常见的情况运行的最快 尽量减少,每个循环内部的缓存不命中数量.","link":"/2022/10/09/1009%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/"},{"title":"CSAPP Optimize 笔记","text":"5.1 编译器优化能力的局限性 编译器只做安全的优化–优化后和未优化的版本有一样的行为 限制 内存别名使用 编译器并不知道指针指向哪里,因此它必须假设指针可能指向同一个位置. 函数调用 大多数编译器不会去判断一个函数是否有副作用,因此它们倾向于将函数的调用保持不变 内联 包含函数调用的代码可以用内联函数替换过程进行优化,就是将函数内部的执行步骤内联到一起 在gcc中,只尝试单文件的内联,不会尝试多文件的内联(比如一组函数在其他文件内的函数中被调用) 5.2 表示程序性能标准:CPE 每元素的周期数 5.3 消除低效循环 例如 :可以拿出来的拿出来 5.4减少过程调用 例: 如果一个循环中不断从结构体中的列表中获取值,而同时,结构体会不断对列表中值的存在进行判断 则可在保证安全的情况下,直接获取结构体中的列表进行访问. 5.5消除不必要的内存引用 例如 123456789{// for loop *dest=*dest+1;}// 将dest这个不断访问内存的东西挪到寄存器里val tmp=*dest;{ tmp=tmp+1;}*dest=tmp 5.6 了解现代处理器 延迟界限 当一系列操作必须按照严格顺序执行时会碰到 因为下一条指令开始前,这一条必须结束 代码中的数据相关限制了处理器利用指令级并行的能力时会碰到延迟界限 吞吐量界限 是处理器功能单元的原始计算能力,是程序性能的终极限制 5.7 循环展开 比如n长的循环,2个一组展开之后,循环长度/2,这种称之为1*2循环展开 对一个n长的循环,进行k级别的展开,就需要将上限设置为n-k+1,这样最大循环索引会小于n 5.8 提高并行性 5.8.1 多个累积变量例: 见书P370 上面的例子称之为2*2循环展开 5.8.2重新结合变换该例子为2*1a循环展开 例 // slow version acc= (acc * data[i]) * data[i+1] //fast version acc = acc * ( data[i] * data[i+1]) slow版里,每次计算都需要等之前的计算结果出来之后才能继续进行 fast版里,data[i]*&amp; data[i+1]不受约束,因此可以被CPU并行优化,故效率高 5.9 一些限制因素书P378 5.9.1 寄存器溢出 当用到的临时变量过多,使得寄存器不够用的时候,会调用栈来存储这些变量,这会使得程序效率变低. 5.9.2 分支预测和预测错误处罚 预测错误会导致较大的错误处罚,那么有什么办法来保证这个处罚对程序效率影响较小呢 不过分关心可预测的分支 例如,大部分结束循环的语句判断都是不结束,预测时一般都按照不结束来判断. 这时候只在最后一次会导致预测错误处罚. 书写适合使用条件传送实现的代码 最好使用条件数据传送而非条件控制转移. 数据传送示例: max=a&gt;b?a:b; 这种形式适合流水线并行操作. 5.10 应用 性能提高技术 高级设计: 为遇到的问题选择适当的算法和数据结构 基本编码原则. 避免限制优化的因素 消除连续的函数调用 在可能时,将计算一道循环外 消除不必要的内存引用 引入临时变量来保存中间结果,只有在最后的值计算出来时,才将结果存放到数组和全局变量中. 低级优化. 结构化代码以利用硬件性能 展开循环,降低开销 使用多个累计变量和重新结合技术,找到方法提高指令级并行 用功能性的风格重写条件操作,使编译采用条件数据传送.","link":"/2022/10/08/1008CSAPP%20Optimize/"},{"title":"CSAPP Machine Level Programming","text":"C 语言 基础属性数组的指针运算– 数组存储的是它的指针,其指针++ 会跳过存储数据量的位置(如 int a[10],a++ ,arr[a]会+4) struct的对齐由于会根据struct中的最大的基本结构类型[int,double,float 之类的,和列表没关系]来进行对齐[例如,struct中存在double就会按照8byte对齐,如果最大只有int,就按照4byte对齐],因此,最好将结构合理组织, 如 12345678910struct S4{//char :1 byte, int : 4byte char c;// 产生3个用于对齐的内存浪费 int i; char d;// 产生3个用于对齐的浪费}// waste 3+3 bytestruct S5{ int i; char c; char d;//c,d一并存储,产生2个用于对齐的浪费} Memory LayoutIMG: Buffer OverFlow 注: 内存是按照0x7FFFFFFFFFFF 也就是2^47来作为地址的,所以各位置之间可能会有较大的差距[因为暂时,硬件条件并不会使得整块可供分配的内存id映射被用尽] stack: 8MB 向下拓展[地址高标号低] Data: 用于存放程序开始时分配的数据 存放全局变量 Heap: 存放通过malloc/相关函数申请的变量,会动态变化 大的数据块会出现在靠近stack的位置,并向下增长,小的数据块会出现在靠近Data的位置,并向上增长 SharedLibraries: 存放库函数代码[一般在磁盘上] 在运行时动态加载到内存中 UnionsBufferOverFlow代码注入攻击详解 举例: gets 会不断读取字符串,直至收到一个’\\0’ 123456void echo(){ char buf[4];/* Way too small*/ gets(buf); puts(buf);} 此时,若输入大于4个字符,echo还是可以接收 查看汇编代码可以看到,调用echo的时候给stackFrame分配了24byte的空间 如果输入大于23个字符,就会报出 segment fault 这时候该函数的返回位置可能被溢出的字符串覆盖,使得函数不会到main这个接口,而是进入一个新的地区 这就是代码注入攻击 小于23就没事, How to Avoid 使用安全的替代 fgets-&gt; gets strncopy-&gt; strcopy scanf(“%ns”)-&gt; scanf(“%s”) Randomized stack offsets– 地址空间布局随机化 使得每次程序运行的时候,它分配到的缓冲区长度都是变化的 None executable code segments 在可读/可写等内存标识之外增加一个 “execute” 权限 stack canary 栈保护机制 程序会检测到栈溢出的问题并返回 A Skill to Avoid Randomized stack offset/None executable code segments 但是躲不开canary GadgetA Example: p后面的值恰好和mov rax rdi 相等,结尾又是一个c3,因此这一段额外的代码会在p赋值之后执行,并返回. 这样就实现了在代码中插入一定量的自己的小代码,返回后就可以通过获取rsp栈中的代码,来将之前的代码块拼接一起执行. GDB Trick disass [FUNC_NAME] 解析对应函数的汇编代码","link":"/2022/10/07/1007csapp_CPu/"},{"title":"CSAPP Linking 笔记","text":"符号和符号表 static属性声明的全局变量/函数都是模块私有的,任意不被static修饰的全局变量/函数都是公共的,可以被其他模块访问 因此,在每个可重定位目标模块中存在三类符号 自己定义的全局符号 由其他模块定义并由该模块引用的全局符号 自己定义的局部符号–static修饰的函数/全局变量 符号解析 编译器解析符号引用的办法是将每个与它输入的可重定位目标文件中的一个确定的符号定义关联起来 如何解析多重定义的全局符号 区别强弱定义: (我的理解) 强定义是全局定义后有初始值,弱定义没有 不允许有多个同名的强符号 如果有一个强符号和多个弱符号同名,则选择强符号 如果多个弱符号同名,则随机选择一个","link":"/2022/10/12/1012%20Linking/"},{"title":"Giant VM 操作过程","text":"主机环境：Windows 11 64位 core i9 12900p 此次使用VMWare Workstation pro 16进行操作 1.环境配置step1 系统准备 win+r 打开cmd sysinfo 查看是否开启了Hyper-V，如果开启应将其关闭 关闭方式 【启用或关闭Windows功能】-&gt; 将虚拟机平台和windows虚拟机监控程序平台关闭 如果看到了Hyper-V的选项框，将其取消勾选 然后重启生效修改 step2 VMware 设置 VMware 中启动Ubuntu16.04配置为内核： Linux4.15.0-112，磁盘分配&gt;40G,在CPU设置中启用嵌套虚拟化 step3 下载必要的包 123sudo apt-get install build-essential openssl libncurses5-dev libssl-devsudo apt-get install zlibc minizip libidn11-dev libidn11 bison flex step4 获得Linux-DSM 1git clone https://github.com/GiantVM/Linux-DSM.git step5 1cd Linux-DSM step6 Enable DSM support 1make menuconfig Virtualization –&gt; KVM distributed software memory support –&gt; press 'Y' to include the option Save –&gt; Exit step7 Compile the Kernel (make) make -jN [N 是] wait for about three hour(or more) 之前的失败经历： Environment: win11 wsl2 Ubuntu16.04 LinuxKernel version 5.10 output : makefile:976: recipe for target 'vmlinux' failed step 8 install the Kernel 12sudo make modules_install sudo make install step 9 update the grub [在我的尝试中，这时候应当先打开grub这个文件][gedit 比较方便看，用vi也可以] 1sudo gedit /etc/default/grub [然后将GRUB_HIDDEN_TIMEOUT 这个属性置为0，不然之后重启的时候没时间换系统] 这自己操作 [然后是核心操作 ] 1sudo update-grub [之后重启] 1reboot [重启后看到下面界面，按照图片选择] [之后等待，启动后，在shell里输入] 1uname -a [可以看到版本为ubuntu 4.9.76+] 2.QEMUstep1 Prepartion sudo apt-get install python pkg-config libglib2.0-dev zlib1g-dev libpixman-1-dev libfdt-devgit clone https://github.com/GiantVM/QEMU.gitcd QEMU step2 Configuration 1./configure --target-list=x86_64-softmmu --enable-kvm step3 Compilation 1make -jN step4 Create hard disk image 12cd ..wget http://ftp.sjtu.edu.cn/ubuntu-cd/16.04.7/ubuntu-16.04.7-server-amd64.iso [如果找不到，可以直接输入http://ftp.sjtu.edu.cn/ubuntu-cd/16.04.7，在里面找到Ubuntu-16.x-server.iso ，然后wget] [这里就是得用apt下一个qemu，选择不下,用底下x86-64_softmmu/ 底下的qemu-system-x86_64会卡死] 123/qemu-img create -f qcow2 ubuntu-server.img 10Gsudo apt-get install qemuqemu-system-x86_64 -m 1024 ubuntu-server.img -cdrom ../ubuntu-16.04.7-server-amd64.iso -enable-kvm [上面会跳出系统设置，基本设置一下用户名和密码，然后会问是否要装载GRUB，选择yes，其他无所谓] 3.Run Giant VM on a single machineFirst we install vncviewer to monitor the guest.12wget https://www.realvnc.com/download/file/viewer.files/VNC-Viewer-6.19.325-Linux-x64.debsudo dpkg -i VNC-Viewer-6.19.325-Linux-x64.deb 如果下面报错说内存不够，把虚拟机关掉，多分配给它一点内存（&gt;8G) terminal 1 : 123cd QEMU/sudo x86_64-softmmu/qemu-system-x86_64 --nographic -hda ubuntu-server.img -cpu host -machine kernel-irqchip=off -smp 4 -m 4096 --enable-kvm -serial mon:stdio -local-cpu 2,start=0,iplist=&quot;127.0.0.1 127.0.0.1&quot; -vnc :0 terminal 2：12cd QEMU/sudo x86_64-softmmu/qemu-system-x86_64 --nographic -hda ubuntu-server.img -cpu host -machine kernel-irqchip=off -smp 4 -m 2048 --enable-kvm -serial mon:stdio -local-cpu 2,start=2,iplist=&quot;127.0.0.1 127.0.0.1&quot; terminal 3:[启动 vncviewer]冒号后面的0和前面 terminal1 后面-vnc 后面的数字对应 1vncviewer :0 如果启动之后看到 nobootable device ，可能需要检查2 QEMU 最后一步的 qemu-system-x86_64 那段是不是正常","link":"/2022/10/01/1001GiantVm%20%E6%93%8D%E4%BD%9C%E8%BF%87%E7%A8%8B%20-ysh/"},{"title":"编码技巧 笔记","text":"1 整洁性 语义简单明确,优先考虑易于读者理解的写法 简洁!=代码短 复杂的问号表达式反而不如 if else 方便理解 个人疑问:问号表达式可以一定程度上提供条件数据传送,而非条件转移 提前返错 提前返回错误判断可以减少主体逻辑的缩进数量,使主体代码逻辑更醒目 利用析构函数做清理工作 利用C++析构函数做清理工作,在复杂冗长代码中不会漏掉. 比如执行回调,关闭文件,释放内存 用朴素直观的算法 在非关键路径上,优先使用朴素直观,维护性好的代码. 用轮询代替条件变量 非关键路径上这么做,代码间接,不容易出bug 轮询: 一直等待信号 在关键对象增加magic字段 增加magic字段和断言检查,可以及时发现内存错误 2 测试 边界 状态/分支测试 重复/幂等性测试 兼容性测试 防御性测试 关注系统在最差情况下的表现,明确能力边界 避免写出不稳定case 例 测试不聚焦，无脑复制粘贴，等价类测试爆炸 异步等待，基于时间假设，sleep 并发，未能在预期的窗口期交互 有顺序依赖的测试，共享某个状态 资源溢出，数据库链接满、内存 OOM 析构随机 core 析构未严格保序或者未构造 多线程共享资源的错误用法导致概率 crash 有未处理完的任务就退出 3 提交 一次提交不要超过400行代码,最好只解决一个问题 自我检查 速度&lt;500行/小时 一次review时间不超过1小时 接口&gt;测试&gt;实现 4 高效工作方法 抽象和分而治之 抽象:明确模块之间的依赖关系,确定API接口 分而治之:对子系统设计进行合理的注释,帮助理解 代码提交尽量做到原子[不可分割的特性.修复.优化],测试代码一同提交 不要重复 寻找重复逻辑和代码,并进行封装 寻找流程重复,使用脚本或者工具自动化 沉淀踩坑经验 快速迭代 不要过度设计 尽快让代码运行和快速验证,不断迭代来完善 为了快速验证,本地测试成本低 实现一个可运行的脚手架,再持续添加内容 忌“太心急”，慢即是快 需求澄清：类似 TCP 三次握手，用自己理解的方式再给对方讲一遍，确认双方理解一致，对焦，避免重复返工 自我提问：为什么做这件事？业务价值是什么？关键技术是什么？已有的系统和它对比有什么不同？兄弟团队是否做过类似的工作？是否有经验可供参考？业务/技术的适用场景是什么？预计耗时和进度风险？ 新人往往脚踏实地，忘记了仰望星空，只顾着埋头苦干，不思考背后的业务价值，这一锄头，那一铁锹，遍地都是坑，就是不开花，费时费力，成就感低。 忌低效沟通，用数据说话 精确地描述问题，上下文和范围，提供有效信息 文档是提高沟通效率的最佳方式之一，Google 有文档文化，推荐阅读《Design Docs at Google》 [5] Bad Case：「测试 CX6 网卡时，IOPS 大幅下降」 Good Case：「在 100g 网络标卡 CX6 验证性能时，8 jobs 32 depth iosize 4K 场景下，极限 IOPS 从 120 万下降至 110 万，与 FIC 卡相比性能存在 8% 差异」 忌“蠢问题”，学会提问 鼓励新人多提问，但提问的问题一定要有质量 关于如何提出一个好问题推荐阅读《提问的智慧》 [6] Bad Case：「我在编译耗时很长，我怀疑是资源不够，这种情况怎么办？」 Good Case：「我的开发机编译耗时 2 小时，不符合预期，OS 是 centOS 7U、128GB 内存、64Core，编译并发度是 20 核，未限制内存，编译过程使用 Top 查看确实 20 核并发，Cpu 和 Mem没有达到瓶颈，iostat 看磁盘使用率每秒 60%」 5 延伸阅读 编写可读代码的艺术 software Engineer at Google 人月神话 数据密集型应用系统设计","link":"/2022/10/12/1012%E7%BC%96%E7%A0%81%E6%8A%80%E5%B7%A7/"},{"title":"论文阅读笔记-Towards a Fully Disaggregated and Programmable Data Center","text":"Abstract目的： 探索建立一个完全分布式的数据中心的可能性。 topLayer: 探索了两种抽象形式，并提出了一种原分布式的方法 bottomLayer: 描述了建立分布式设备与连接它们的网络基础设施所需的硬件和关键功能。 connection：提出了一个静态时间组价，它将不同的用户程序编译到异构的分布式设备中，通过一个disaggregation-native 的中间表示法。 同时提出了一个运行时的系统，他管理硬件资源，并安排编译器生成的执行单元。 Introduction现有的问题： 应用的颗粒化和硬件性能增长速度的限制，对分布式数据中心提出了要求。 而现有的分布式解决方案无法对网络和计算器进行分布。 同时，现有的数据中心网络的设计目的是连接服务器，但是，怎么高效地连接分布式设备呢？ 最后，目前仍不清楚如何将应用映射到一个分布式的硬件平台。 两种设想的抽象类型 向后兼容的抽象，用户不知道硬件性质，他们会认为程序在虚拟机上运行，完全与服务器无关。 向应用程序暴露部分分布式、可编程的底层性质。这种类型会有更好的 性能，因为用户可以直接控制并利用低层次的系统功能。如网络通信等。 实现应用的分布式映射 不同于以往的分布式架构，这里使用Intetmediate Representation 作为中层架构。它是围绕着分解执行单元的概念进行的。 用MLIR将程序分解成小编码块 如何在FDP-DC中建立硬件基础设施 提供了建立一个分布式设备的指导方针，并却行了它的三个方针，网络连接性，硬件虚拟化和多用户隔离 设想了一个可重配置的网络架构 runtime management system FDP-DC OS 监督整个资源池，在规划的时候会采用编译器的提示 FDP-DC Design","link":"/2022/10/02/1002%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-Towards%20a%20Fully%20Disaggregated%20and%20Programmable/"},{"title":"csapp 异常控制流","text":"1013 异常控制流Exception Control Flow ECF1.1 异常处理 启动时生成异常表 运行时检测到异常,确定异常号,查找异常表,进入处理程序 执行完后,执行一条”从中断返回”指令,将控制返回给被中断的程序[如果是一个用户程序被中断] 1.2异常类别 中断 陷阱和系统调用 陷阱: 有意的异常,用来在用户程序和内核之间提供一个像过程一样的接口–系统调用 故障 如 除法错误,却也,一般保护故障[程序引用了一个未定义的虚拟内存区域,Linux一般会报告为一个 段故障 Segmentation fault] 终止 不可恢复的致命错误–通常硬件错误 2 进程定义 一个执行中程序的实例 维护一个 该程序是系统中当前运行的唯一程序的假象 拥有 一个独立的逻辑控制流 提供独占处理器的假象 一个私有的地址空间 提供独占内存系统的假象 进程空间给出通用结构 以x86-64 Linux为例 上下文切换用于实现多任务 上下文: 重新启动一个被抢占的进程所需的状态 系统调用错误处理Unix系统级函数遇到错误时,通常会返回-1,并设置全局整数变量errno来表示什么出错了. 进程控制重点是创建子进程 父进程调用fork函数创建一个子进程 父子进程区别 相同 虚拟地址空间 代码 数据段 堆 共享库 用户栈 打开描述符 意味着父进程调用fork时,子进程可以读写父进程中打开的任何文件 区别 Pid 进程id不同 并发执行 父进程和子进程是并发运行的独立进程 虚拟地址空间 子进程得到的副本和父进程相同,包括打开的文件描述符,但是是一份独立的副本,也就是说,之后的调用,子进程和父进程独立. fork 调用一次返回两次 一次是在调用进程(父进程中) 返回子进程PID(非零) 一次在创建的进程中(子进程中) 返回0 可以用来辨认子进程还是父进程 回收子进程步骤: 终止-&gt;分配给init进程作为养父-&gt;父进程回收[若父进程没来得及回收,则由init进程回收] 信号较高层 是一个小消息,通知进程系统中发生了一个某种类型的事件. 用于通知用户进程发生了一些低层的硬件异常","link":"/2022/10/13/1013%20%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/"},{"title":"编码技巧 笔记","text":"1012编写可读代码的艺术 阅读笔记 表面改进1.代码应当易于理解可读性: 代码的写法应当使别人理解它所需的时间最小化 2.将信息装入名字里 选择专业的词 避免泛泛的名字 用具体的名字代替抽象的名字 使用前缀/后缀给名字附带更多信息 决定名字的长度 小作用域短名字 首字母缩略词– 需要易于理解 丢掉没用的词 利用名字的格式表达含义 3.不会误解的名字4.审美 使用一致的布局,让读者很快习惯这种风格 让相似的代码看上去相似 把相关的代码行分组,形成代码块 5.该写什么样的注释不该写什么注释? 不要为那些从代码本身就能快速推断的事实写注释 不要为了注释而注释 不要给不好的名字加注释–应该把名字改好 该写什么? 记录思想 记录写代码时有过的重要想法 比如加入”导演评论” 为代码中的瑕疵写注释 给常量加注释 公布可能的陷阱 全局观注释–类之间如何交互等 6.写出言简意赅的注释 让注释保持紧凑 避免不明确的代词 润色粗糙的句子 精确描述函数行为 用输入输出例子来说明 声明代码意图 采用信息量高的词 逻辑改进7.把控制流变的易读 比较语句 左侧倾向于变化值,右侧倾向于固定值 最小化嵌套 提前返回 这是个好事 8.拆分超长表达式思想:拆成小块 9.变量与可读性 减少变量 去掉没有价值的临时变量 减少中间结果 减少控制流变量 缩小变量的作用域 重新组织代码10.抽取不相关的子问题如果一段代码并不是为了这个代码块的高层次目标直接工作,可以将其抽取处理. 11.一次只做一件事如题 12.把想法变成代码最好按自然理解的逻辑组织代码","link":"/2022/10/13/1013%E7%BC%96%E5%86%99%E5%8F%AF%E8%AF%BB%E4%BB%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF%20%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"title":"qemu cxl","text":"123456789./build/aarch64-softmmu/qemu-system-aarch64 -M virt,gic-version=3,cxl=on -m 4g,maxmem=8G,slots=8 -cpu max \\-hda ../vm_disk/ubuntu_cxl.qcow2 \\-cdrom ../ubuntu-20.04.5-desktop-amd64.iso \\-object memory-backend-file,id=cxl-mem1,share=on,mem-path=/tmp/cxltest.raw,size=256M \\-object memory-backend-file,id=cxl-lsa1,share=on,mem-path=/tmp/lsa.raw,size=256M \\-device pxb-cxl,bus_nr=12,bus=pcie.0,id=cxl.1 \\-device cxl-rp,port=0,bus=cxl.1,id=root_port13,chassis=0,slot=2 \\-device cxl-type3,bus=root_port13,memdev=cxl-mem1,lsa=cxl-lsa1,id=cxl-pmem0 \\-M cxl-fmw.0.targets.0=cxl.1,cxl-fmw.0.size=4G -M Libnvdimm 12345678910111213~/qemu/build/aarch64-softmmu/qemu-system-aarch64 -M virt,gic-version=3,cxl=on -m 4g,maxmem=8G,slots=8 -cpu max \\-bios ~/repo/edk2/Build/ArmVirtQemu-AARCH64/DEBUG_GCC48/FV/QEMU_EFI.fd \\-kernel ~/linux/arch/arm64/boot/Image \\-initrd ./rootfs.cpio.gz \\-monitor telnet:127.0.0.1:4444,server,nowait \\-object memory-backend-file,id=cxl-mem1,share=on,mem-path=/tmp/cxltest.raw,size=256M \\-object memory-backend-file,id=cxl-lsa1,share=on,mem-path=/tmp/lsa.raw,size=256M \\-device pxb-cxl,bus_nr=12,bus=pcie.0,id=cxl.1 \\-device cxl-rp,port=0,bus=cxl.1,id=root_port13,chassis=0,slot=2 \\-device cxl-type3,bus=root_port13,memdev=cxl-mem1,lsa=cxl-lsa1,id=cxl-pmem0 \\-cxl-fixed-memory-window targets.0=cxl.1,size=4G \\-append &quot;console=ttyAMA0 root=/dev/ram rdinit=/init acpi=on&quot; \\-nographic \\ 1234567make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- menuconfigmake ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- -j16sudo make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- modules_installsudo make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- installsudo update-grubreboot","link":"/2022/10/15/qemu-cxl/"}],"tags":[{"name":"exp8","slug":"exp8","link":"/tags/exp8/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"class3","slug":"class3","link":"/tags/class3/"},{"name":"操作系统,计算机","slug":"操作系统-计算机","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"软件体系结构","slug":"软件体系结构","link":"/tags/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"name":"计网","slug":"计网","link":"/tags/%E8%AE%A1%E7%BD%91/"},{"name":"网络地址","slug":"网络地址","link":"/tags/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80/"},{"name":"网络层","slug":"网络层","link":"/tags/%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"MC","slug":"MC","link":"/tags/MC/"},{"name":"软件质量与评测技术","slug":"软件质量与评测技术","link":"/tags/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E8%AF%84%E6%B5%8B%E6%8A%80%E6%9C%AF/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"},{"name":"database","slug":"database","link":"/tags/database/"},{"name":"computer","slug":"computer","link":"/tags/computer/"},{"name":"csapp","slug":"csapp","link":"/tags/csapp/"},{"name":"android","slug":"android","link":"/tags/android/"},{"name":"计算机","slug":"计算机","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"VM","slug":"VM","link":"/tags/VM/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"技巧","slug":"技巧","link":"/tags/%E6%8A%80%E5%B7%A7/"},{"name":"编码","slug":"编码","link":"/tags/%E7%BC%96%E7%A0%81/"},{"name":"qemu","slug":"qemu","link":"/tags/qemu/"}],"categories":[{"name":"大三","slug":"大三","link":"/categories/%E5%A4%A7%E4%B8%89/"},{"name":"操作系统","slug":"大三/操作系统","link":"/categories/%E5%A4%A7%E4%B8%89/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"大四","slug":"大四","link":"/categories/%E5%A4%A7%E5%9B%9B/"},{"name":"上交","slug":"大四/上交","link":"/categories/%E5%A4%A7%E5%9B%9B/%E4%B8%8A%E4%BA%A4/"},{"name":"笔记","slug":"笔记","link":"/categories/%E7%AC%94%E8%AE%B0/"}],"pages":[{"title":"about","text":"Nothing","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index-1.html"},{"title":"about","text":"","link":"/about/index-1.html"}]}